```text
the plt(procedure linkage table) and got(global offset table) is a part of linux's addressing
functionality for dynamically linked binaries
```
```
GOT:
the global offset table is a table of addresses that lies within .data, notice how it resides within
read and write memory, not .rodata.
```
this will become important later with format string vulnerabilities

the GOT will store the addresses of the functions, in which the dynamic binary will use to call them
```
PLT:
the procedure linkage table essentially points to the addresses at GOT, when you call printf@plt,
instead of calling the function directly, it will first call an entry within PLT,
which then calls the function
```
the plt resides within the executable .text section of the dynamically linked binary

the addresses locations are resolved with what is called lazy resolution/lazy binding

the order in which this goes is

first, the function is called within the binary
example:
```
call printf@plt
```
```text
the program execution is then jmp'd to the plt, which will point to the global offset table
if the program has already been called, and the address is already known, the GOT will point program
execution to the desired location, then ret control back into the binary

if this is the first time the function is called(no previous instances of this one particular function)
then the global offset table will point back to the PLT's address resolution procedure.

the PLT's address resolution procedure is pretty complicated and will take too much time, so
the important part of it, is that it resolves the addresses of the function calls and updates GOT

the NT/windows equivalent to the GOT/PLT is the IAT(import address table), but we will not talk
about that today

that may sound a little convoluted at first, but i will try my best to explain each of them.

when binaries are linked, they can be statically linked, or dynamically linked
this means that the binary either has all functions it uses built inside of the binary, or it will
call out the the plt, which then gives it the address of the function call within memory
the addresses of function calls are not known during linked, but are dynamically resolved during runtime
hence then name, dynamic linking

when you statically link a binary, all of the external functions you use will be stuffed inside the
binary, which increases size but is important for portability and removes the need for external
dependencies that the host system may not have
```
lets try an example:
```c
#include <stdio.h>
int main() {
    printf("jotaro");
    return 0;
}
```
lets compile this little piece of code dynamically
```bash
gcc dy.c -o dy
```
now lets see which shared libraries this binary has been linked to
```bash
ldd dy
```
output:
```nasm
linux-vdso.so.1 (0x00007fff7a3e6000)
libc.so.6 => /usr/lib/libc.so.6 (0x00007f443f8a7000)
/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007f443faae000)
```
now lets do that again, lets do "ldd dy" again and again

what do you notice is changing?

the addresses of the shared libraries in memory are constantly changing, this is all thanks to aslr
which randomizes memory, but we will get to that later i just wanted to show a little example.

now we can see which shared libraries the binary is linked to, lets reverse this binary and see the
function call
```nasm
0000000000001139 <main>:
    1139:       55                      push   rbp
    113a:       48 89 e5                mov    rbp,rsp
    113d:       48 8d 3d c0 0e 00 00    lea    rdi,[rip+0xec0]        # 2004 <_IO_stdin_used+0x4>
    1144:       b8 00 00 00 00          mov    eax,0x0
    1149:       e8 e2 fe ff ff          call   1030 <printf@plt>
    114e:       b8 00 00 00 00          mov    eax,0x0
    1153:       5d                      pop    rbp
    1154:       c3                      ret
    1155:       66 2e 0f 1f 84 00 00    cs nop WORD PTR [rax+rax*1+0x0]
    115c:       00 00 00
    115f:       90                      nop
```
now we see the disassembly, we can see that it is initializing the stack frame, loading the address
of our "jotaro" string into rdi(destination register), calling printf, and returning 0 through eax
now lets take a look back at our printf call
```nasm
call   1030 <printf@plt>
```
this calls "printf@plt", a global variable that will point to the address of printf.

this is how functions are called dynamically, now lets try compiling the binary statically
```bash
st.c: gcc st.c -static -o st
```
lets disassemble the main() function:
```nasm
0000000000401795 <main>:
  401795:       55                      push   rbp
  401796:       48 89 e5                mov    rbp,rsp
  401799:       48 8d 3d 64 18 08 00    lea    rdi,[rip+0x81864]        # 483004 <_IO_stdin_used+0x4>
  4017a0:       b8 00 00 00 00          mov    eax,0x0
  4017a5:       e8 c6 85 00 00          call   409d70 <_IO_printf>
  4017aa:       b8 00 00 00 00          mov    eax,0x0
  4017af:       5d                      pop    rbp
  4017b0:       c3                      ret
  4017b1:       66 2e 0f 1f 84 00 00    cs nop WORD PTR [rax+rax*1+0x0]
  4017b8:       00 00 00
  4017bb:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]
```
now before we do anything, note the fact that there are tons and tons of functions within the library
even though we have the exact same code
that means that all the functions were thrown inside our binary for us to use

we see that it does the same thing as the other binary, it establishes the stack frame, loads the address
of the string into rdi, calls printf, returns 0, and restores stack frame and program execution back to
the return address.

lets take another look at printf now:
```nasm
call   409d70 <_IO_printf>
```
now we notice that instead of calling printf@plt, it will call printf or an address within the binary

that is what static and dynamic linking is

if you think something was worded incorrectly, or think i should have elaborated on something feel

free to scream at me on discord at: manjoos#0745

thank you for reading! :)
