# This challenge is fun and cool

Thanks to trigleos for helping me notice the incorrect xor operations

i dont know his github, i only talk to the guy on discord, so i cant exactly
link anything, anyways thanks man i would have never caught it.

loc.l1  = password incorrect

loc.l2  = exit

```
the algorithm goes like this
it will iterate through our input
xor eax, 0x14
shr/shift right twice
so if we are to reverse this, we need to first shift left twice
then xor eax 0x14(20), since that would bring it back to the original
THE XOR VALUES ARE WRONG!1!, the xor site i have been using does not know
what they were doing. the decimal, and shifts are all correct values, but the
chart should give an accurate approximation of how this challenge was solved.

og      decimal shlx2   xor     ascii value
0x1f    = 31    = 124   = 118    = v
0x1e    = 30    = 120   = 114    = r
0x18    = 24    = 96    = 106    = j
0x19    = 25    = 100   = 110    = n
0x1e    = 30    = 120   = 114    = r
0x12    = 18    = 72    = 66     = B
0x18    = 24    = 96    = 106    = j
0x1e    = 30    = 120   = 114    = r
0x12    = 18    = 72    = 66     = B
0x1d    = 29    = 116   = 126    = ~
0x19    = 25    = 100   = 110    = n
0x19    = 25    = 100   = 110    = n
0x1c    = 28    = 112   = 122    = z
0x1e    = 30    = 120   = 114    = r
0x1d    = 29    = 116   = 126    = ~
0x1e    = 30    = 120   = 114    = r
0x1b    = 27    = 108   = 102    = f
```
fucked up my XOR, the site i was using was complete bs.

never trust the interwebz, i wrote my own implementation of the bit shifts and xor to automatically
solve as long as the data was entered correctly.

here is the source:
```c
#include <stdio.h>// use printf instead of streams, overlapping operators!
// all encrypted characters in decimal
unsigned int data[]={31, 30, 24, 25, 30, 18, 24, 30, 18, 29, 25, 25, 28, 30, 29, 30, 27};
int main(int argc, char**argv) {
    for (int i=0;i<sizeof(data)/sizeof(data[0]);i++) {
        printf("%c", (data[i]<<2)^0x14);// 20 in decimal
    }
    return 0;
}
```
lil script that works just fine, the data of the remote server might be constantly changing who knows, but this returns the password:
```
hltpl\tl\`ppdl`lx
```
and the flag:
```
GLUG{intro_to_assembly}
```
