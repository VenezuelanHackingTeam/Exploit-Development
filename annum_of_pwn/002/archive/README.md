# Use After Free - Concept - 4/13/21
this entry will not be so much a pwn challenge as it is just simply understanding a concept.
Use After Free vulnerabilities are caused by dangling pointers left after the use of dynamic memory
allocators. When we call a function like ptmalloc() within glibc, it will return a pointer to the
allocated chunk of memory. This pointer is how we will be able to reach our allocated memory, next, if
we were to free() that memory in which our pointer, points to. It would deallocate and free that
memory, but would not destroy the pointer, which is called a "dangling pointer". It is a pointer
that points to nonexistent memory, and can lead to security implications if that pointer is used in
an insecure context.

That is the best explanation of what a Use After Free is without getting too into the specifics, so
now that we semi understand this concept, we can begin to find ways in which we can use this attack
vector. In this post, we will be basing our first challenge off of the 34C3CTF - simpleGC.

After that challenge writeup and complete explanation is over, I will be following along with
CVE-2018-4878, a Use-After-Free vulnerability within Adobe Flash. I had chosen to base my first
1-day POC off of this CVE due to the fact that adobe flash is terrible software. I have nothing
against it, but any software that has this many vulnerabilities of the same class is just bad software.

Our last and final 1-day POC of this post will be on "Microsoft Internet Explorer".
The CVE descriptions says "Object Memory Use-After-Free", which sounds interesting enough. This seems
like a very good introduction to browser exploitation, so i will be using this CVE as my third and
last challenge of this post, now lets recap what we will be doing today.

1. 34C3CTF - simpleGC
2. CVE-2018-4878
3. MS10-002

This time around, we will have more windows NT pwns then our precious ELF binaries, which will be a
touch learning process but an important one.

## 34C3CTF - simpleGC
Lets first start off with a much much simpler challenge that will provide us with the understanding
of how UAF bugs work, and the techniques employed to successfully exploit them.

for this first binary, i will be using a custom packing and aslr script that you can find here:
https://github.com/0xmanjoos/Exploit-Development/tree/main/fastpwn

you can install the library simply with:

pip install fastpwn

[*] '/tmp/jail/sgc'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)

alrighty, now that we have all of the dependencies installed lets start our static analysis of our binary
lets check the output when we run it:

0: Add a user
1: Display a group
2: Display a user
3: Edit a group
4: Delete a user
5: Exit
Action:

we are prompted with a menu of sorts which allows us to add, display, edit, and delete. This is an
interesting set of options, as we can already deduce what each of these will most likely be. Add will
malloc a few bytes to store our user on the heap, display will print out the data from either a group
or user, edit is still unknown to me, but we will figure that out later, and delete will free() that
user off the heap.

With these kinds of menu challenges, we usually have an index in which we can find our allocation, and
we will be indexing an integer array that stores pointers to allocated chunks on the heap. Lets begin
reverse engineering each of these options, and the menu function.

void *user_list[96];
void *group_list[96];

int main() {
    int input;

    setvbuf(stdin, 0, 2, 0);
    setvbuf(stdout, 0, 2, 0);
    alarm(0xa0);
    pthread_create(&var_10h, 0, 0x40127e, 0);
    while (input != 5) {
        puts("0: Add a user");
        puts("1: Display a group");
        puts("2: Display a user");
        puts("3: Edit a group");
        puts("4: Delete a user");
        puts("5: Exit");
        printf("Action: ");
        input = scanf("%d", &input);
        if (input == 0) {
            add_user();
        }
        if (input == 1) {
            group_display();
        }
        if (input == 2) {
            user_display();
        }
        if (input == 3) {
            group_edit();
        }
        if (input == 4) {
            delete_user();
        }
    }
    puts("Bye");
    exit(0);
}

char *read_string(int64_t a1, uint64_t a2) {
    char *result; // rax
    uint64_t v3; // [rsp+18h] [rbp-8h]

    v3 = 0LL;
    do
    {
        if ( read(0, (void *)(a1 + v3), 1uLL) == -1 )
            exit(1);
        if ( *(char *)(a1 + v3) == 10 )
        {
            result = (char *)(a1 + v3);
            *(char *)(a1 + v3) = 0;
            return result;
        }
        ++v3;
    }
    while ( v3 < a2 );
    result = (char *)(v3 - 1 + a1);
    *result = 0;
    return result;
}

void *find_group(const char *group_name) {

    for ( i = 0; i <= 95; ++i )
    {
        if ( group_list[i] && !strcmp(group_name, group_list[i]) && group_list[i] + 8) )
        {
            ++group_list[i] + 8);
            return group_list[i];
        }
    }
    return 0LL;
}

char *new_group(const void *group_name) {
    void *new_group_name;
    char *group;
    char *group_1;
    new_group_name = malloc(24uLL);
    group = malloc(16uLL);
    group_1 = group;
    group[8] = 1;
    *(int64_t *)group = new_group_name;
    memcpy(*(void **)group, group_name, 24uLL);
    return group_1;
}

void *add_group(int64_t group_name) {
    unsigned __int16 i; // [rsp+1Eh] [rbp-12h]

    for ( i = 0; i <= 95u && group_list[i]; ++i )
        ;
    if ( i > 95u )
        exit(1);
    group_list[i] = new_group((const void *)group_name);
    return group_list[i];
}

long add_user() {
    unsigned int user_name_len; // ST14_4
    int64_t *user; // rbx
    unsigned __int16 i; // [rsp+Eh] [rbp-162h]
    char age; // [rsp+10h] [rbp-160h]
    int64_t *group; // [rsp+18h] [rbp-158h]
    char age_buf; // [rsp+20h] [rbp-150h]
    char group_name; // [rsp+30h] [rbp-140h]
    char user_name; // [rsp+50h] [rbp-120h]
    uint64_t v9; // [rsp+158h] [rbp-18h]

    memset(&user_name, 0, 256uLL);
    memset(&age_buf, 0, 8uLL);
    memset(&group_name, 0, 24uLL);
    printf("Please enter the user's name: ", 0LL);
    read_string((int64_t)&user_name, 192uLL);
    printf("Please enter the user's group: ", 192LL);
    read_string((int64_t)&group_name, 24uLL);
    printf("Please enter your age: ", 24LL);
    read_string((int64_t)&age_buf, 4uLL);
    age = atoi(&age_buf);
    group = find_group(&group_name);
    if ( !group )
        group = add_group((int64_t)&group_name);
    for ( i = 0; i <= 95u && user_list[i]; ++i )
        ;
    if ( i > 95u )
    {
        puts("User database full");
        exit(1);
    }
    user_list[i] = malloc(24uLL);
    *((int64_t *)user_list[i] + 2) = *group;
    *(char *)user_list[i] = age;
    user_name_len = strlen(&user_name) + 1;
    user = user_list[i];
    user[1] = malloc(user_name_len);
    memcpy(*((void **)user_list[i] + 1), &user_name, user_name_len);
    puts("User created");
}

int print_user(unsigned __int8 *user) {
    printf("User:\n\tName: %s\n\tGroup: %s\n\tAge: %u\n", *((int64_t *)user + 1), *((int64_t *)user + 2), *user);
}

long display_user() {
    unsigned int index; // [rsp+Ch] [rbp-14h]
    char buf; // [rsp+10h] [rbp-10h]
    uint64_t v3; // [rsp+18h] [rbp-8h]

    printf("Enter index: ");
    read_string((int64_t)&buf, 4uLL);
    index = atoi(&buf);
    if ( index <= 95 )
    {
        if ( user_list[index] )
            print_user((unsigned __int8 *)user_list[index]);
        else
            printf("No users at %u\n", index);
    }
    else
    {
        puts("invalid index");
    }
}

long display_group() {
    unsigned int i; // [rsp+Ch] [rbp-34h]
    char group_name; // [rsp+10h] [rbp-30h]
    uint64_t v3; // [rsp+38h] [rbp-8h]

    printf("Enter group name: ");
    read_string((int64_t)&group_name, 24uLL);
    for ( i = 0; i <= 95; ++i )
    {
        if ( user_list[i] && !strcmp(&group_name, *((const char **)user_list[i] + 2)) )
            print_user((unsigned __int8 *)user_list[i]);
    }
}

void remove_one_user_from_group(const char *group_name) {
    unsigned __int16 i; // [rsp+1Eh] [rbp-2h]

    for ( i = 0; i <= 95u; ++i )
    {
        if ( group_list[i] && !strcmp(group_name, *(const char **)group_list[i]) )
        {
            if ( *((char *)group_list[i] + 8) )
                --*((char *)group_list[i] + 8);
        }
    }
}

long delete_user() {
    unsigned int index; // [rsp+Ch] [rbp-14h]
    char buf; // [rsp+10h] [rbp-10h]
    uint64_t v3; // [rsp+18h] [rbp-8h]

    printf("Enter index: ");
    read_string((int64_t)&buf, 4uLL);
    index = atoi(&buf);
    if ( index <= 95 )
    {
        if ( user_list[index] )
        {
            remove_one_user_from_group(*((const char **)user_list[index] + 2));
            free(user_list[index]);
            user_list[index] = 0LL;
        }
    }
    else
    {
        puts("invalid index");
    }
}

void delete_empty_groups(void *a1) {
    unsigned int i; // [rsp+18h] [rbp-8h]

    sleep(1u);
    while ( 1 )
    {
        for ( i = 0; i <= 95; ++i )
        {
            if ( group_list[i] )
            {
                if ( !*((char *)group_list[i] + 8) )
                {
                    free(*(void **)group_list[i]);
                    free(group_list[i]);
                    group_list[i] = 0LL;
                }
            }
        }
        sleep(0);
    }
}

long edit_group() {
    int index; // [rsp+Ch] [rbp-54h]
    int64_t *group; // [rsp+10h] [rbp-50h]
    char buf; // [rsp+20h] [rbp-40h]
    char group_name; // [rsp+30h] [rbp-30h]
    uint64_t v5; // [rsp+58h] [rbp-8h]

    printf("Enter index: ");
    read_string((int64_t)&buf, 4uLL);
    index = atoi(&buf);
    if ( user_list[index] )
    {
        printf(
            "Would you like to propagate the change, this will update the group of all the users sharing this group(y/n): ",
            4LL);
        read_string((int64_t)&buf, 2uLL);
        printf("Enter new group name: ", 2LL);
        if ( buf == 'y' )
        {
            read_string(*((int64_t *)user_list[index] + 2), 24uLL);
        }
        else
        {
            read_string((int64_t)&group_name, 24uLL);
            group = find_group(&group_name);
            if ( group )
                *((int64_t *)user_list[index] + 2) = *group;
            else
                *((int64_t *)user_list[index] + 2) = *(int64_t *)add_group((int64_t)&group_name);
        }
    }
}

essentially, what this program is doing is prompting us with a choice to either add, display, edit, or
delete. In our add user function, it will ask us to provide a user name, group name, and age. Within
our display functions, it will prompt for an index, while the display_group function will prompt for
a group name. We will get into the specifics on how these names and index's are kept track of. Delete
will do exactly that, it will prompt us for an index to the user, and free that index from our
user_list struct.

as we can see, we have 2 global integer arrays that will store the users and groups pointers. Lets
figure out what data will be stored for a user type, and a group type. If we look back at our user_create
function we can see that it will prompt us, asking for the user's name, group's name, and age:

struct user {
    char* user_name;
    char* group_name;
    int age;
};

next, we can define a group type, which wont be explicitly created, but each user will be assigned
to a group. So when we create a user, it must be assigned to a group name, and if you were to create
another user with the same group name, they would be assigned to the same group. This is a very
interesting application.

struct group {
    char* group_name;
    int user_count;
};

the vulnerability within this binary lies within our edit_group and remove_from_group function that
resides within our main edit_group. The function does not do any checking to see if that name has
already been taken when changing the name, so 2 group objects will have the same "char* group_name"
parameter. This is interesting, as it means when we call our delete function, all names within
group_list will be iterated through, and checked to see if that user_name exists. If so, it will
decrement our user_count entry within that group, and move on.

So lets think about this, we have 2 users that we have allocated with DIFFERENT GROUP names:

User:
        Name: a
        Group: a
        Age: 1
User:
        Name: b
        Group: b
        Age: 1

Now lets edit group a's group name, into "b"

0: Add a user
1: Display a group
2: Display a user
3: Edit a group
4: Delete a user
5: Exit
Action: 3
Enter index: 0
Would you like to propagate the change, this will update the group of all the users sharing this group(y/n): y
Enter new group name: b
0: Add a user
1: Display a group
2: Display a user
3: Edit a group
4: Delete a user
5: Exit
Action:

so as we can see, it has allowed us to edit the name of group "a" into "b", now its important to remember
that these two groups are not technically "in the same group", they are in different chunks of memory,
but share the same name. Lets rerun the binary, except this time we will attempt to create our dangling
pointer.

0: Add a user
1: Display a group
2: Display a user
3: Edit a group
4: Delete a user
5: Exit
Action: 0

Please enter the user's name: a
Please enter the user's group: a
Please enter your age: 1
User created

0: Add a user
1: Display a group
2: Display a user
3: Edit a group
4: Delete a user
5: Exit
Action: 0

Please enter the user's name: b
Please enter the user's group: b
Please enter your age: 1

User created
0: Add a user
1: Display a group
2: Display a user
3: Edit a group
4: Delete a user
5: Exit
Action: 3

Enter index: 0
Would you like to propagate the change, this will update the group of all the users sharing this group(y/n): y
Enter new group name: b

0: Add a user
1: Display a group
2: Display a user
3: Edit a group
4: Delete a user
5: Exit
Action: 1

Enter group name: b
User:
        Name: a
        Group: b
        Age: 1
User:
        Name: b
        Group: b
        Age: 1

0: Add a user
1: Display a group
2: Display a user
3: Edit a group
4: Delete a user
5: Exit
Action: 4
Enter index: b

0: Add a user
1: Display a group
2: Display a user
3: Edit a group
4: Delete a user
5: Exit
Action: 2

Enter index: 0
No users at 0

0: Add a user
1: Display a group
2: Display a user
3: Edit a group
4: Delete a user
5: Exit
Action: 2
Enter index: 1

User:
        Name: b
        Group: 9
        Age: 1

0: Add a user
1: Display a group
2: Display a user
3: Edit a group
4: Delete a user
5: Exit
Action:

Now as we can see, our group now points to an area within memory, because looking back at my input i have
no recollection of calling "b"'s "9". So now that we understand where our UAF bug is on the surface level
we need to begin digging deeper, and finding ways to use this bug to gain code execution in some way.

This bug works both ways as well, if we allocated users and groups names as "a" and "b", edit "a"'s
group name to "b", and delete "b" user, we will get a dangling pointer. We know this when we output
the user "a"'s profile:

Enter index: 0
User:
        Name: a
        Group:
        Age: 1

as we can see, it now doesnt point to any group, it points to where that data used to reside.

By the way, this program is multithreaded, and by multithreaded i mean 2 threads. One thread is for us
to operate on, our menu and all, the second thread is for background processes like indexing, searching,
and garbage collection. When we "delete" a user, it will be passed the group_name, then will search
for and free() the group that it is tied to.

Since we have 2 threads within a multithreaded program, this introduces a new level of complexity with
ptmalloc's dynamic memory. There is a data structure that exists on the stack called the tcache, if
you are not familiar with this, i reccomend you check out my dynamic memory allocators post:

https://github.com/0xmanjoos/Exploit-Development/blob/main/HEAP/dynamic_memory/README.md

An important thing to keep in mind that it is a caching mechanism meant for the optimization
of threaded POSIX programs which had been introduced with the creation of ptmalloc, in which stands for
POSIX thread aware malloc. The creation of ptmalloc and ptmalloc2 introduced some complex, effective,
and somewhat insecure optimization mechanisms, some of these include bins, tcache, and arenas.

The mechanism we will be talking about today is called tcache, which stands for thread local caching.
It's name gives away it's purpose, as it is meant to optimize the use of dynamic allocators within
threaded programs. Now that i have given a brief refresher, i hope that we understand tcache well enough
to continue with the exploitation of this binary, and if not then i reccomend first learning about
the internals of glibc's ptmalloc first.

anyways, its important to note that EACH THREAD WILL HAVE IT'S OWN TCACHE STRUCTURE. This means that
this program will have 2 tcache structures in total, which increases the complexity of the exploitation
of this binary. We should first debug our program to find which thread's tcache will cache deleted
groups and users.

lets first start the program up in gdb, then create user "a", "b", with each group name, named
respectively. We can now start up the program and delete BOTH of them, then SIGTERM the program
and we can begin to inspect the state of this binary.

gef➤  info threads
  Id   Target Id                              Frame
* 1    Thread 0x7ffff7da0740 (LWP 9761) "sgc" 0x00007ffff7e9308c in read () from /usr/lib/libc.so.6
  2    Thread 0x7ffff7d9f640 (LWP 9766) "sgc" 0x00007ffff7e6a125 in clock_nanosleep@GLIBC_2.2.5 () from /usr/lib/libc.so.6
gef➤  thread 1
[Switching to thread 1 (Thread 0x7ffff7da0740 (LWP 9761))]
#0  0x00007ffff7e9308c in read () from /usr/lib/libc.so.6
gef➤

so as we can see, we can find how many threads are running within the current process with "info threads"
this will allow us to switch between each thread, and inspect each tcache that exists within both these
processes. Lets switch to thread 1 and check it's tcache state

gef➤  heap bins
────────────────────────────────── Tcachebins for arena 0x7ffff7f64a00 ──────────────────────────────────
Tcachebins[idx=0, size=0x20] count=1  ←  Chunk(addr=0x603460, size=0x20, flags=PREV_INUSE)
─────────────────────────────────── Fastbins for arena 0x7ffff7f64a00 ───────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
────────────────────────────────── Unsorted Bin for arena 'main_arena' ──────────────────────────────────
[+] Found 0 chunks in unsorted bin.
─────────────────────────────────── Small Bins for arena 'main_arena' ───────────────────────────────────
[+] Found 0 chunks in 0 small non-empty bins.
─────────────────────────────────── Large Bins for arena 'main_arena' ───────────────────────────────────
[+] Found 0 chunks in 0 large non-empty bins.
gef➤

as we can see from the output of Tcachebins, there is 1 entry with the chunk size of 0x20 bytes. Lets
check our second thread's tcache state.

gef➤  thread 2
[Switching to thread 2 (Thread 0x7ffff7d9f640 (LWP 9766))]
#0  0x00007ffff7e6a125 in clock_nanosleep@GLIBC_2.2.5 () from /usr/lib/libc.so.6
gef➤  heap bins
────────────────────────────────── Tcachebins for arena 0x7ffff7f64a00 ──────────────────────────────────
Tcachebins[idx=0, size=0x20] count=1  ←  Chunk(addr=0x603460, size=0x20, flags=PREV_INUSE)
─────────────────────────────────── Fastbins for arena 0x7ffff7f64a00 ───────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
────────────────────────────────── Unsorted Bin for arena 'main_arena' ──────────────────────────────────
[+] Found 0 chunks in unsorted bin.
─────────────────────────────────── Small Bins for arena 'main_arena' ───────────────────────────────────
[+] Found 0 chunks in 0 small non-empty bins.
─────────────────────────────────── Large Bins for arena 'main_arena' ───────────────────────────────────
[+] Found 0 chunks in 0 large non-empty bins.
gef➤

hm interesting, it seems as though 1 thread will be caching our group, and the other our user. Again, as
we had previously stated that tcache was for optimization of threaded programs, when we call malloc()
before allocating any memory with brk, or mmap, it will first look through that thread's own tcache.

we have just recapped how
