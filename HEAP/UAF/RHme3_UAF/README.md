# RHme3_CTF Use After Free
Since their shitty shitty binary doesnt work on any local machine due to the "background process" checks put in place, i have
rewritten the entire binary. They did not bother to provide the source either because they are small and bad people so i had to
figure out what they were doing completely from radares disassembly. This was fun to reverse engineer though and i had made some
small adjustments, like removing redundant flushes of stdout stream and dumb checks.

this was a great binary to demonstrate the security implications that dangling pointers may present within an application. In this
case we will have read and write access to our dangling pointer within dynamic memory, which will allow us to leak the populated GOT
entry of any function we want, which would then leak the address of that function within memory. This will allow us to bypass ASLR and
use anything within libc.

Something that should be noted is that, the function that we leak should also be the one that we will be overwriting, which means we will
have to be able to control what gets sent to that function. If we were to leak the address of system, that would not work in the long run as
we would not have any way of calling system. 

That was just an example as system is not an imported function within this binary, so there will not be any static PLT/GOT entries within
the binary itself. So what function DO we control user input to?
```c
void edit_name(){ // shell
    char buffer[50];
    printf("Enter new name: ");
    read(0,buffer,50);
    buffer[strcspn(buffer,"\n")]=0;
    int len = strlen(buffer);// < --
    //we will overwrite this GOT entry, and since we are read()ing it, we can execute anything
    strcpy(players[slt]->name, buffer);
}
```
as we can see from this function, if we were to overwrite the GOT entry of strlen, we would be able to pass our "buffer" parameter to it, which
is a char array that WE control. This is great, normally we would be able to do this simply with a pop rdi gadget, but we dont actually have
any control on the stack. There is no buffer to overflow, just some heap memory that we control.
