# RHme3_CTF Use After Free
Since their shitty shitty binary doesnt work on any local machine due to the "background process" checks put in place, i have
rewritten the entire binary. They did not bother to provide the source either because they are small and bad people so i had to
figure out what they were doing completely from radares disassembly. This was fun to reverse engineer though and i had made some
small adjustments, like removing redundant flushes of stdout stream and dumb checks.

this was a great binary to demonstrate the security implications that dangling pointers may present within an application. In this
case we will have read and write access to our dangling pointer within dynamic memory, which will allow us to leak the populated GOT
entry of any function we want, which would then leak the address of that function within memory. This will allow us to bypass ASLR and
use anything within libc.

Something that should be noted is that, the function that we leak should also be the one that we will be overwriting, which means we will
have to be able to control what gets sent to that function. If we were to leak the address of system, that would not work in the long run as
we would not have any way of calling system. 

That was just an example as system is not an imported function within this binary, so there will not be any static PLT/GOT entries within
the binary itself. So what function DO we control user input to?
```c
void edit_name(){ // shell
    char buffer[50];
    printf("Enter new name: ");
    read(0,buffer,50);
    buffer[strcspn(buffer,"\n")]=0;
    int len = strlen(buffer);// < --
    //we will overwrite this GOT entry, and since we are read()ing it, we can execute anything
    strcpy(players[slt]->name, buffer);
}
```
as we can see from this function, if we were to overwrite the GOT entry of strlen, we would be able to pass our "buffer" parameter to it, which
is a char array that WE control. This is great, normally we would be able to do this simply with a pop rdi gadget, but we dont actually have
any control on the stack. There is no buffer to overflow, just some heap memory that we control.

so lets recap:
1. Create a dangling pointer, allocate object, and free object; pointer has not been destroyed due to poor practice
2. edit that freed "name" with the address of strlen's static GOT entry
3. then, displaying user will print out the resolved address of strlen within memory thanks to _\_dl_runtime_resolve
4. now that we have the address of system, we can simply edit name again, which will allow us to overwrite the GOT entry of strlen
5. then edit name, AGAIN, due to the fact that it contains the strlen(buffer); that we need to execute a command we want


here is the source code to the binary:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define true 1
#define false 0
#define PAGE 4096
#define MAX_PLAYERS 11
// the author of this challenge does not know how to write c code for shit
typedef unsigned int bool;// works better than define
typedef struct player {
    int attack;
    int defense;
    int speed;
    int precision;
    char name[50];
}p;
int idx,slt=0;
p* players[MAX_PLAYERS];

void add_player() {
    char* str;
    int i=0;
    while (i<MAX_PLAYERS&&players[i]!=0) {//iterate until free or too many
        i++;
    }
    if (idx==MAX_PLAYERS) {
   puts("Maximum number of players reached!");
        fflush(stdout);
    } else {
        printf("found free slot: %d\n",i);
        fflush(stdout);// why they do this? there is no need??
        p* new_p = (p*)malloc(sizeof(p));
        if (new_p==NULL) {
            puts("Could not allocate");
        }else{
            printf("Enter players name: ");\
            read(0,new_p->name,50);
            new_p->name[strcspn(new_p->name,"\n")]=0;//remove trailing \n
            printf("Enter attack point: ");
            scanf("%d",&new_p->attack);
            printf("Enter defense point: ");
            scanf("%d",&new_p->defense);
            printf("Enter speed: ");
            scanf("%d",&new_p->speed);
            printf("Enter precision: ");
            scanf("%d",&new_p->precision);
            players[idx]=new_p;
            idx++;
        }
    }
}
void delete_player() {
    int input;
    printf("Enter index: ");
    scanf("%d",input);
    if(input<MAX_PLAYERS&&players[input]!=0) {
        free(players[input]);
        puts("She\'s gone!");
    } else {
        puts("Invalid Index!");
    }
}
void select_player() {
    int input;
    printf("Enter index: ");
    scanf("%d",&input);
    if(input<MAX_PLAYERS&&players[input]!=0) {
        puts("Player selected!");
        printf("\nName: %s",players[input]->name);
        printf("\tA/D/S/P: %d/%d/%d/%d\n\n",
        players[input]->attack,
        players[input]->defense,
        players[input]->speed,
        players[input]->precision );
        slt=input;
    } else {
        puts("Invalide Index");
    }
}
void edit_name(){ // shell
    char buffer[50];
    printf("Enter new name: ");
    read(0,buffer,50);
    buffer[strcspn(buffer,"\n")]=0;

    //we will overwrite this GOT entry, and since we are read()ing it, we can execute anything
    strcpy(players[slt]->name, buffer);
}
void edit_attack(){
    printf("Enter attack points: ");
    scanf("%d", &players[slt]->attack);
}
void edit_defense(){
    printf("Enter defense points: ");
    scanf("%d", &players[slt]->defense);
}
void edit_speed(){
    printf("Enter speed points: ");
    scanf("%d", &players[slt]->speed);
}
void edit_precision(){
    printf("Enter precision points: ");
    scanf("%d", &players[slt]->precision);
}
void edit_player() {
    int input;
    bool check = false; // very bad way to implement a check, but it is what it is
    // fuck you, i love goto statements
    if (!idx>0&&slt>=0) {//if player exists and if selected points to existing index
        puts("No player has been selected!");goto die;
    }
    while (1) {
        puts("1.- Edit name");
        puts("2.- Edit attack");
        puts("3.- Edit defense");
        puts("4.- Edit speed");
        puts("5.- Edit precision");
        puts("6.- Exit");
        printf("Enter: ");
        scanf("%d",&input);
        switch(input) {
        case 1:
            edit_name();
            break;
        case 2:
            edit_attack();
            break;
        case 3:
            edit_defense();
            break;
        case 4:
            edit_speed();
            break;
        case 5:
            edit_precision();
            break;
        case 6:
            goto die;
        default:
            puts("Invalid choice!");
        }
    die: return;
    }
}
void show_player() {
    int input;
    printf("Enter index: ");
    scanf("%d",&input);
    if (input>=idx) {
        puts("player doesnt exist!");
    } else {
        printf("\nName: %s\tA/D/S/P: %d/%d/%d/%d\n\n",
        players[input]->name,
        players[input]->attack,
        players[input]->defense,
        players[input]->speed,
        players[input]->precision);
    }
}
void show_team() {
    for (int i=0;i<idx;i++) {
        printf("\nName: %s\tA/D/S/P %d/%d/%d/%d\n\n",
        players[i]->name,
        players[i]->attack,
        players[i]->defense,
        players[i]->speed,
        players[i]->precision);
    }
}
int main(int argc,char**argv) {
    int input;
    puts("Welcome to your TeamManageer (TM)!");
    fflush(stdout);
    while (1) {
        puts("0.- Exit\n1.- Add player\n2.- Remove player\n3.- Select player");
        puts("4.- Edit player\n5.- Show player\n6.- Show team");
        printf("Your choice: ");
        scanf("%d",&input);

        switch(input) {
        case 0:
            exit(0);
            break;
        case 1:
            add_player();
            break;
        case 2:
            delete_player();
            break;
        case 3:
            select_player();
            break;
        case 4:
            edit_player();
            break;
        case 5:
            show_player();
            break;
        case 6:
            show_team();
            break;
        default:
            puts("Invalid option!!");
        }
    }
    return 0;
}
__attribute__((constructor))
void setup(){
    alarm(120);// reduce load on server if program has not been terminated, feel free to patch local
    setbuf(stdout,NULL);
}
```
