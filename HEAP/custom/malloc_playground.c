#include "malloc_playground.h"
void n(int sig){signal(SIGINT,n);puts("\nType \"exit\" to exit!");}
int parse(const char* cmd) {
    int optarg;
    for (int i=0;options[i]!=0;i++) {
        if(strcmp(cmd,options[i])==0) {
            optarg=i+1;            
        }
    }
    return optarg;
}

int _real_chunk_size(void*ptr) {
    int size = *(int*)(ptr-8);
    return size;
}
int _usable_chunk_size(void*ptr) {
    return (_real_chunk_size(ptr) - 9);
}
void* handle(void* arg) {
    char buffer[100],cmd[100];

    printf("> ");
    if(!read(0,buffer,sizeof(buffer) - 1))goto die;

    /* vulnerable, can write exactly 100 bytes then no null term line :/ */
    buffer[strcspn(buffer,"\n")]=0;

    sscanf(buffer,"%s %d %d",cmd,&arg1,&arg2);

    switch(parse(cmd)) {
    case 1:
        if (arg1==1337||arg2==1337) {
            puts("error!");
        }else {
            for (i=0;i<arg2;i++) {
                if (chunkptrs_n<MAX_CHUNKS) {
                    for (j=0;j<MAX_CHUNKS;j++){
                        if(!chunkptrs[j]) {
                            chunkptrs[j]=(void*)malloc(arg1);
                            break;
                            break;
                        }
                    }
                }else {
                    puts("Not enough space left!");
                    break;
                }
                printf("malloc'd chunk index: %d @ %p\n",chunkptrs_n,chunkptrs[chunkptrs_n]);
                chunkptrs_n++;
            }
        }
        /* really weird solution, but hey it works */
        arg1=1337,arg2=1337;
        break;

    case 2:
        if (arg1==1337) {
            puts("error!");
            break;
        }
        if(!chunkptrs_n) {
            puts("No chunks left! ");
            break;
        }
        if (arg1<0||arg1>MAX_CHUNKS||!chunkptrs[arg1]) {
            puts("Could not find chunk!");
            break;
        }

        free((void*)chunkptrs[arg1]);
        printf("freed chunk id: %d @ %p\n",arg1,chunkptrs[arg1]);
        chunkptrs[arg1]=NULL; // no dangle >:(
        chunkptrs_n--;
        break;

    case 3:
        for (int chunk = 0 ; chunk < MAX_CHUNKS ; chunk ++) {
            if (chunkptrs[chunk]!=NULL) {
                free(chunkptrs[chunk]);
                chunkptrs[chunk]=NULL;
            }
        }
        chunkptrs_n=0;
        puts("Freed all!");
        break;

    case 4: /* arg1 == index; arg2 == size */
        if(arg1==1337||arg2==1337){
            puts("error!");
            break;
        }
        if(chunkptrs[arg1]) {
            printf("Enter data to write: ");
            read(0,chunkptrs[arg1],arg2);
            
            /* check is being implemented AFTER the read! */

            if(arg2>=_usable_chunk_size(chunkptrs[arg1])) {
                printf("Write size too large!\n");
                break;
            }

            printf("Written to chunk index %d @ %p\n",arg1,chunkptrs[arg1]);
        }else {
            printf("No chunk at index: %d\n",arg1);
        }
        break;

    case 5:
        /* OOB read, we can simply read the unsorted bin without heap feng shui? */

        if(arg1==1337||arg2==1337) { //to make sure params is not empty, weird solution but it works */
            puts("error!");
            break;
        }
        if (!chunkptrs[arg1]){
            puts("Chunk does not exist!");
            break;            
        }
        for(int i=0;i<arg2;i++) {
            putchar(*((char*)chunkptrs[arg1]+i));
        }
        putchar((char)0xa);
        break;

    case 6:
        if (arg1==1337){puts("error!");break;}
        if (!chunkptrs[arg1])break;
        printf("usable chunk size: %d\n",_usable_chunk_size(chunkptrs[arg1]));
        break;
    case 7:
        if(arg1==1337){puts("error!");break;}
        if(!chunkptrs[arg1])break;
        printf("real chunk size: %d\n",_real_chunk_size(chunkptrs[arg1]));
        break;
    case 8:
        for (int a=0;a<MAX_CHUNKS;a++) {
            if (chunkptrs[a]) {
                printf("Chunk %d @ %p\nSize: %d\n",a,chunkptrs[a],_usable_chunk_size(chunkptrs[a]));
            }
        }
        break;
    case 9:
        exit(0);
        break;

    default:puts("malloc, free, freeall, edit, read, usable, real, chunks, help, exit");
    }
    memset(buffer,0,sizeof(buffer));
die:return NULL;
}

int main(int argc,char**argv) {
    signal(SIGINT,n);
    while(1) {
    	handle(0);
    }
}

void STUB __attribute__((section(".stubby"))) s() {
    /* 
      file descriptors 0,1,2 are FILE structures in glibc, we do not want output buffering 
      no buffering will write out when it receives the bytes/data.
      next mode will wait for 0xa byte before it writes
      last will wait until buffer has been filled, then will write
    */
    setbuf(stdin,0);setbuf(stdout,0);setbuf(stderr,0);
    fprintf(stderr,"pid: %d\n",getpid());
}
