; This code will not run, nor will it assemble
; this is just an explanation on how the heap1 binary functions
push   ebp                         ; this seems to be an x86 binary, hehe nice
mov    ebp,esp                     ; establish stack frame
and    esp,0xfffffff0              ; round the stack pointer
sub    esp,0x20                    ; allocate space
mov    DWORD PTR [esp],0x8         ; mov the value 8 into the address of stack pointer??

call   80483bc <malloc@plt>        ; ok, now malloc is called, so i have a few questions here
                                   ; does malloc take esp as a parameter?
   ; i know we are allocing 8 bytes on the heap, so this is the only sensible conclusion i have for this
   ; im also wondering about that, maybe malloc takes parameters on the stack in x86 as well?
   ; because we are moving it to the ADDRESS of esp right?, which points to the top of the stack
   ; which means that is the same thing as push, just gcc optimizing it right?
   ; its just a theory, but it was the only logical one i could come up with in my head

mov    DWORD PTR [esp+0x14],eax    ; pointer to address on heap returned through eax
mov    eax,DWORD PTR [esp+0x14]    ; store it as a variable on the stack

                                   ; this is very interesting i think i have a plausible theory
mov    DWORD PTR [eax],0x1         ; this is changing the value of priority "i1->priority=1"
                       ; i believe this is it, due to the fact that we had allocated
                       ; the struct on the heap, "i1 = malloc(sizeof(struct internet));"
                       ; which is what eax points to, eax points to the allocated struct on the heap
                       ; and the first entry on that struct is priority, which is exactly it.
                       ; another theory, im just lobbing these and hoping they land

mov    DWORD PTR [esp],0x8         ; mov 8 back onto the top of the stack
call   80483bc <malloc@plt>        ; calls malloc for name parameter
                                   ; "i1->name = malloc(8);"
                 ; i got a little confused at this part, until remembered that there is a nested malloc
                 ; now eax = i1->name = malloc(8);
                 ; [esp+0x14] = i1 = malloc(sizeof(struct internet)); ; size_t = 8

mov    edx,eax                     ; edx now contains pointer to nested allocated space on the heap
mov    eax,DWORD PTR [esp+0x14]    ; store pointer to heap on another local variable
mov    DWORD PTR [eax+0x4],edx     ; eax [eax+0x4] = i->name
mov    DWORD PTR [esp],0x8         ; push 8 on the top of the stack again
call   80483bc <malloc@plt>        ; call another malloc, this time i am assuming it is for i2

mov    DWORD PTR [esp+0x18],eax    ; eax is the pointer to address on heap, [esp+0x18] = malloc(8);
mov    eax,DWORD PTR [esp+0x18]    ; eax = *i2
mov    DWORD PTR [eax],0x2         ; i2->priority = 2 ; eax points towards the first entry in the struct
mov    DWORD PTR [esp],0x8         ; mov 8 into the top of the stack again to prepare for another malloc
call   80483bc <malloc@plt>        ; malloc, pointer returned through eax
mov    edx,eax                     ; edx = i2->name = malloc(8)
mov    eax,DWORD PTR [esp+0x18]    ; *i2 = eax ; pointer to i2 moved into eax
mov    DWORD PTR [eax+0x4],edx     ; mov pointer to allocated memory on heap into name
                                   ; we move up by 4, which is the name variable
                                   ; i2->name = *malloc(8);

; now this one is peculiar, there are 2 more mallocs, and i have checked the source for this area
; there should not be any more mallocs, we have finished initializing internet1 and 2, the only
; functions left are strcpy() and printf, so our best bet is to research into strcpy
; here are the full lines for strcpy:
;
; strcpy(i1->name, argv[1]);
; strcpy(i2->name, argv[2]);
;
; now from what we had just researched, strcpy inherintly does not utilize any heap operations
; what about i1->name? arent we accessing members on the heap?
; i dont think so either, we already have pointers to the heap address stored on the stack
; there would be no reason to malloc 16 more separate bytes on the heap?
;
; wait im stupid i copied too much mallocs, that is a mistake on my end
; ok whatever im just going to keep those notes since they explain the next part well
; sorry for the confusing, i had copied too many mallocs, that scared me for a bit
; please dont allow the rambling to confuse you, everything i have said in this particular area is
; null and void :)

; ok lets continue to the strcpy
mov    eax,DWORD PTR [ebp+0xc]     ; move the pointer to argv into eax
add    eax,0x4                     ; move the pointer from argv[0] to argv[1]
mov    eax,DWORD PTR [eax]         ; mov the dereference pointer of argv[1] into eax
mov    edx,eax                     ; move the pointer into edx, probably as an src parameter for strcpy
mov    eax,DWORD PTR [esp+0x14]    ; mov the pointer to i1 into eax
mov    eax,DWORD PTR [eax+0x4]     ; change the pointer from i1->priority to i1->name
mov    DWORD PTR [esp+0x4],edx     ; [esp+0x4] points to i1->name, which was allocated on a separate
                                   ; area on the heap
                                   ; edx points to argv[1], which means that it is changing i1->name
                                   ; into a pointer to argv[1], which makes sense kind of
; i had personally thought that we would provide these parameters as registers, but i guess
; thats not the case, at least in my eyes, feel free to point out anything that went wrong
; during this explanation process if im blabbering nonsense

mov    DWORD PTR [esp],eax         ; mov eax to the top of the stack, eax points to il->name
call   804838c <strcpy@plt>        ; then call strcpy, src and dest provided, argv[1] and i1->name
mov    eax,DWORD PTR [ebp+0xc]     ; mov eax to point to argv[0] again
add    eax,0x8                     ; change pointer from argv[0] to argv[2]
mov    eax,DWORD PTR [eax]         ; mov eax into the dereference pointer to eax
                                   ; which should be the value of argv[2]
mov    edx,eax                     ; mov dereference pointer to argv[2] into edx
mov    eax,DWORD PTR [esp+0x18]    ; mov pointer to i2 into eax
mov    eax,DWORD PTR [eax+0x4]     ; mov dereference pointer of i2 into eax
                                   ; eax = i2->name ; eax+0x4 serves to access name, not priority

mov    DWORD PTR [esp+0x4],edx     ; edx = *argv[2] ; we are moving pointer to argv[2] into i2->name
mov    DWORD PTR [esp],eax         ; then we move the address of i2->name to the top of the stack
call   804838c <strcpy@plt>        ; then we call strcpy, copies everything from argv[2] into i2->name
mov    DWORD PTR [esp],0x804864b   ; moves address of string into [esp], TOP OF THE STACK
call   80483cc <puts@plt>          ; then we call puts(this should be printf, but optimized by gcc)
leave                              ; deallocate
ret                                ; return from procedure ; pop eip into ret addr
