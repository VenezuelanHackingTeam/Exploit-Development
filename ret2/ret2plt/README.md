## ret2plt

in this exploitation technique, we will be able to leak the plt entry of a function within libc
then from that leak, we are able to discover the base address of libc. This base address means that
we are allowed to access whatever we want within the provided libc by the challenge.

ASLR will load our libc into some random address within memory. In order to disallow write permissions
to our pages in memory, we will need to use the PLT and GOT to resolve and call functions within our
loaded libc.

Now, in comes ret2plt, which essentially renders the entire concept of ASLR useless.
the program must rely on a fixed PLT that was created during dynamic linking.

the PLT and GOT addresses are not randomized, so we can still see where they point to in memory.

in the case with our exploit, we will use a rop gadget, and the addresses of the PLT/GOT entries
in order to leak an address from libc.

We can target puts(), which is part of our binary.
This binary was dynamically linked, which means the calls to the GOT and PLT are static, while the memory
that they reach out to is not.

this is how our payload essentially works:

payload = b"A"*offset
payload += pop_rdi              # our gadget will pop the next thing on the stack into rdi
payload += p64(p.got['puts'])   # in x64 calling convention, rdi will be the first parameter to puts
payload += p64(p.plt['puts'])   # we call puts, we will print out wherever the got entry to puts
                                # is pointing to
payload += p64(main)            # we will call main again, as long as the program doesnt terminate,
                                # our address space will not be randomized again

then, with the REAL address of puts within memory, we can find the base address to puts, then profit
we can do any simple ret2libc trick now that we have the offset. We can even get fancy and use a quick
one gadget, since those exist within libc and will save us time.

