# ret2dlresolve

### note: this post assumes prior knowledge in these categories:
### 1. GOT/PLT

### 2. Return Oriented Programming

ret2dlresolve is an exploitation technique for bypassing ASLR, and is useful when you do not
know the version of the remote system's libc.

here is the source of this technique:
http://phrack.org/issues/58/4.html

this means that an arbitrary read or info leak is no longer required for exploiting a remote
buffer overflow on linux. we have ways of bypassing these stack protections like ret2plt, ret2csu, and
the topic we will be covering today, ret2dlresolve.
```
the basis of this exploitation technique is that, we have a GOT entry of each function within libc, but
for optimization they are only dynamically resolved on runtime by the PLT. They are resolved using the
_dl_runtime_resolve function. When there is no GOT entry for a specific function within libc, the PLT
will then attempt to dynamically resolve the address with our _dl_runtime_resolve function. PLT will
then update the GOT and jmp to the function. This is called lazy binding, which is a form of binary
optimization that improves startup time, but introduces interesting exploitation techniques as a result
of that. What i think this symbolizes, is that we should always be implementing new and wild ideas into
our production code, since this gives us pwners more bugs :)
```
Lazy binding and dynamic address resolution can be summed up completely with this pseudo code
```c
int printf@plt {
    if (first_call) {
        call _dl_runtime_resolve(link_map, rel_offset);
    } else {
        jmp *(printf@got);
    }
}
```
we will call printf, which if dynamically linked will jmp to our Procedure Linkage Table.
This will then check if there is a GOT entry, if this is the first time it has been called then
it will call _dl_runtime_resolve. 

This will find printf within memory, cache it's address on the GOT
and call it. If printf has already been called, and there is a GOT entry present, it will just
jmp to it. This is how the GOT, PLT, and lazy binding work in tandem with each other to make dynamic
binaries possible in linux.

Some things that should be noted, this exploitation technique will not work on every system. If the
dynamic loader does bounds checking, or if massive page sizes are enabled, this will not work.
Just something to keep in mind, it should work just fine on glibc :)

lets talk through the steps in which we can achieve ret2dlresolve.
```
1. create a fake Elf32_Sym struct that contains the name of the function we want to resolve.
2. pass arguments from registers or stack for the function
3. call __dl_runtime_resolve with the offset of our functions relocation entry
```
to craft our fake struct and get the base address to use as an offset, we can create it in a few
places. We can create our fake struct on the heap, .bss, or any other safe writeable chunk of memory.

in this case, we do not have any heap operations within the binary so the heap will not have been
allocated, and it will no longer be an option. So lets use the .bss section of our ELF binary.

lets take a look at one of our data structures that will exist within the ELF binary. This is what
our symbol table should look like, if we were to create a fake symbol table(), with an offset
to a fake symbol. We would then pass this to __dl_runtime_resolve and it would call __dl_fixup, which
would then dynamically attempt to resolve, update, and jmp to our fake symbol, which will point to
system() or whatever function we want it to point to.

the JMPREL section, also known as .rel.plt, is the relocation table. This will map and store entries to
each symbol within the binary. Each of these entries will use the Elf32_Rel struct.
```c
typedef struct {
    Elf32_Word    st_name;   /* Symbol name (string tbl index) */
    Elf32_Addr    st_value;  /* Symbol value */
    Elf32_Word    st_size;   /* Symbol size */
    unsigned char st_info;   /* Symbol type and binding */
    unsigned char st_other;  /* Symbol visibility under glibc>=2.2 */
    Elf32_Section st_shndx;  /* Section index */
} Elf32_Sym;

Typedef struct {
    Elf32_Addr r_offset; /* got.plt entry */
    Elf32_Word r_info;   /* index from symbol table */
} Elf32_Rel;
```
here are the important sections of our binary, this is what we will be creating entries for.
```nasm
.rel.plt    (Elf_Rel entry)
.dynsym     (Elf_Sym entry)
.dynstr
```
we will first need to create our fake Elf32_Rel(.rel.plt) entry, in which we will need to fill 2 members.
The first is r_offset, where we will use a fake GOT entry that will point to system(). The next value we
need to fill is r_info, which is the index from our Elf32_Sym table. 

This one, we will need to calculate the address of. As have already determined, we will be writing our 
fake entries to .bss, so our offset between our .bss section and our .dynsym entry will be 12 bytes in decimal.

there will be 3 stages to our exploit, first payload will read our input into the plt.
it will then return to main, and call our vulnerable function again. Our second payload will scan
our fake entries into bss, and call our vuln function again. The last and final payload will simply
execute __dl_runtime_resolve, and if all arguments were passed correctly, we should get a shell
from system().
```
we have the following parameters being passed: _dl_runtime_resolve(link_map, reloc_index);
once these are passed to our dl_runtime_resolve, it will then find a Elf32_Rel struct within the
.rela.plt section of our binary. It will then calculate the index inside the Elf32_Rel field called
r_info. After it has calculated the index to locate another struct called Elf32_Sym within .dynsym.
Within this struct it will calculate and access another value called st_name. Finally, it will
use this index to locate our "puts\0" stringin .dynstr. Obviously we are assuming that puts will
be our function call, and if it were then this challenge would have been so much simpler.
```
We, however can overwrite this data and change the pointers and calculations into whichever function
we want, in which __dl_resolve_runtime will resolve, update the GOT entry, and call. So we are
essentially attacking the dynamic resolving process and lazy binding in which glibc uses.

Here is an amazing ascii diagram that i stole from:

https://github.com/ss8651twtw/blog/blob/master/docs/writeup/0CTF-2018-Quals:Baby-Stack.md
```
     _dl_runtime_resolve(link_map, reloc_arg)
                                       +
          +-----------+                |
          | Elf32_Rel | <--------------+
          +-----------+
     +--- | r_offset  |        +-----------+
     |    |  r_info   | -----> | Elf32_Sym |
     |    +-----------+        +-----------+      +----------+
     |      .rel.plt           |  st_name  | +--> | system\0 |
     |                         |           |      +----------+
     v                         +-----------+        .dynstr
+----+-----+                      .dynsym
| <system> |
+----------+
  .got.plt
```
i do not have permission to use it, but its demonstrates how _dl_runtime_resolve extremely well, and
i dont think i could have created a better graph on how it works.

we need to create 2 fake Elf32_Rel and Elf32_Sym structs, the pass it to _dl_runtime_resolve. This
exploit comes packed with an extremely confusing way of calculating the offset in r_info. This is an
extremely important part of this technique, so let me first explain what r_info is within Elf32_Rel.

This member gives both the symbol table index with respect to which the relocation must be made, and the
type of relocation to apply. For example, a call instruction's relocation entry would hold the symbol
table index of the function being called. Here we can see the macro that defines r_info.
```c
#define ELF32_R_INFO(s,t) (((s)<<8)+(unsigned char)(t))
```
as we can see, it will shift s by 8 bits, then add that with "t" which has the type unsigned char casted
on it. This may seem very confusing, and it is confusing for me as well but this is just how it works.
As the famous king crimson quote goes, "it just works". I like to keep that in mind when approaching
new concepts, as it reminds me that these systems server a purpose, as sometimes they seem to just be
around to complicate things. 

Though, as long as we follow this macro's formula for calculating r_info, it should work just fine.
```c
0x7 | ((locationOfFakeSymtab - symtab) / 16) << 8
```
as long as we follow this formula when calculating the address in which the resolved function should
be written to. Lets walk through this formula and explain what it does, step by step. We provide the
address of our fake FakeSymtab subtracted by the offset to the real symbol table offset. We divide
this by 16, bit shift left by 8, then bitwise operator "or" by 7. For our attack to work, the lower 8
bits must be 0x7 (R_386_JMP_SLOT). The high 24 bits helps the binary find the location of the fake
symtab. Then, I do an extra 4 bytes for alighment afterwards.

Obviously, a massive mitigation against this technique is Position Independent Executable. This means
that our actualy executable will also be randomized when loaded into memory. This is truly the most
devastating exploit mitigation, as combined with ASLR it is impossible to exploit a simple stack overflow
without an arbitrary read or leak. 

Though as of right now, we do not have to worry about our binary being loaded at a random address, this 
means that our PLT/GOT entries will be at a static address, along with our binary sections. We will not 
have to calculate the base address of our binary in memory, and use that offset to reach each section and symbol.

Now lets take a look at our challenge code:
```c
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void vuln() {
    char buf[100];
    setbuf(stdin, buf);
    read(0, buf, 256);
}
int main() {
    char buf[100] = "Hello There!\n";
    setbuf(stdout, buf);
    write(1, buf, strlen(buf));
    vuln();
    return 0;
}
```
We can compile the code with the following flags:
```
-fno-stack-protector -m32 -no-pie -o bug
```
