# ret2dlresolve

### note: this post assumes prior knowledge in these categories:
### 1. GOT/PLT
https://github.com/0xmanjoos/Exploit-Development/tree/main/fmt_bug/GOT-PLT

### 2. Return Oriented Programming

https://github.com/0xmanjoos/Exploit-Development/tree/main/ret2/ROP

ret2dlresolve is an exploitation technique for bypassing ASLR, and is useful when you do not
know the version of the remote system's libc.

here is the source of this technique:
http://phrack.org/issues/58/4.html

this means that an arbitrary read or info leak is no longer required for exploiting a remote
buffer overflow on linux. we have ways of bypassing these stack protections like ret2plt, ret2csu, and
the topic we will be covering today, ret2dlresolve.
```
the basis of this exploitation technique is that, we have a GOT entry of each function within libc, but
for optimization they are only dynamically resolved on runtime by the PLT. They are resolved using the
_dl_runtime_resolve function. When there is no GOT entry for a specific function within libc, the PLT
will then attempt to dynamically resolve the address with our _dl_runtime_resolve function. PLT will
then update the GOT and jmp to the function. This is called lazy binding, which is a form of binary
optimization that improves startup time, but introduces interesting exploitation techniques as a result
of that. What i think this symbolizes, is that we should always be implementing new and wild ideas into
our production code, since this gives us pwners more bugs :)
```
Lazy binding and dynamic address resolution can be summed up completely with this pseudo code
```c
int printf@plt {
    if (first_call) {
        call _dl_runtime_resolve(link_map, rel_offset);
    } else {
        jmp *(printf@got);
    }
}
```
we will call printf, which if dynamically linked will jmp to our Procedure Linkage Table.
This will then check if there is a GOT entry, if this is the first time it has been called then
it will call _dl_runtime_resolve. 

This will find printf within memory, cache it's address on the GOT
and call it. If printf has already been called, and there is a GOT entry present, it will just
jmp to it. This is how the GOT, PLT, and lazy binding work in tandem with each other to make dynamic
binaries possible in linux.

Some things that should be noted, this exploitation technique will not work on every system. If the
dynamic loader does bounds checking, or if massive page sizes are enabled, this will not work.
Just something to keep in mind, it should work just fine on glibc :)

lets talk through the steps in which we can achieve ret2dlresolve.
```
1. create a fake Elf32_Sym struct that contains the name of the function we want to resolve.
2. pass arguments from registers or stack for the function
3. call __dl_runtime_resolve with the offset of our functions relocation entry
```
to craft our fake struct and get the base address to use as an offset, we can create it in a few
places. We can create our fake struct on the heap, .bss, or any other safe writeable chunk of memory.

in this case, we do not have any heap operations within the binary so the heap will not have been
allocated, and it will no longer be an option. So lets use the .bss section of our ELF binary.

lets take a look at one of our data structures that will exist within the ELF binary. This is what
our symbol table should look like, if we were to create a fake symbol table(), with an offset
to a fake symbol. We would then pass this to __dl_runtime_resolve and it would call __dl_fixup, which
would then dynamically attempt to resolve, update, and jmp to our fake symbol, which will point to
system() or whatever function we want it to point to.

the JMPREL section, also known as .rel.plt, is the relocation table. This will map and store entries to
each symbol within the binary. Each of these entries will use the Elf32_Rel struct.
```c
typedef struct {
    Elf32_Word    st_name;   /* Symbol name (string tbl index) */
    Elf32_Addr    st_value;  /* Symbol value */
    Elf32_Word    st_size;   /* Symbol size */
    unsigned char st_info;   /* Symbol type and binding */
    unsigned char st_other;  /* Symbol visibility under glibc>=2.2 */
    Elf32_Section st_shndx;  /* Section index */
} Elf32_Sym;

Typedef struct {
    Elf32_Addr r_offset; /* got.plt entry */
    Elf32_Word r_info;   /* index from symbol table */
} Elf32_Rel;
```
here are the important sections of our binary, this is what we will be creating entries for.
```nasm
.rel.plt    (Elf_Rel entry)
.dynsym     (Elf_Sym entry)
.dynstr
```
we will first need to create our fake Elf32_Rel(.rel.plt) entry, in which we will need to fill 2 members.
The first is r_offset, where we will use a fake GOT entry that will point to system(). The next value we
need to fill is r_info, which is the index from our Elf32_Sym table. 

This one, we will need to calculate the address of. As have already determined, we will be writing our 
fake entries to .bss, so our offset between our .bss section and our .dynsym entry will be 12 bytes in decimal.

there will be 3 stages to our exploit, first payload will read our input into the plt.
it will then return to main, and call our vulnerable function again. Our second payload will scan
our fake entries into bss, and call our vuln function again. The last and final payload will simply
execute __dl_runtime_resolve, and if all arguments were passed correctly, we should get a shell
from system().
```
we have the following parameters being passed: _dl_runtime_resolve(link_map, reloc_index);
once these are passed to our dl_runtime_resolve, it will then find a Elf32_Rel struct within the
.rela.plt section of our binary. It will then calculate the index inside the Elf32_Rel field called
r_info. After it has calculated the index to locate another struct called Elf32_Sym within .dynsym.
Within this struct it will calculate and access another value called st_name. Finally, it will
use this index to locate our "puts\0" stringin .dynstr. Obviously we are assuming that puts will
be our function call, and if it were then this challenge would have been so much simpler.
```
We, however can overwrite this data and change the pointers and calculations into whichever function
we want, in which __dl_resolve_runtime will resolve, update the GOT entry, and call. So we are
essentially attacking the dynamic resolving process and lazy binding in which glibc uses.

Here is an amazing ascii diagram that i stole from:

https://github.com/ss8651twtw/blog/blob/master/docs/writeup/0CTF-2018-Quals:Baby-Stack.md
```
     _dl_runtime_resolve(link_map, reloc_arg)
                                       +
          +-----------+                |
          | Elf32_Rel | <--------------+
          +-----------+
     +--- | r_offset  |        +-----------+
     |    |  r_info   | -----> | Elf32_Sym |
     |    +-----------+        +-----------+      +----------+
     |      .rel.plt           |  st_name  | +--> | system\0 |
     |                         |           |      +----------+
     v                         +-----------+        .dynstr
+----+-----+                      .dynsym
| <system> |
+----------+
  .got.plt
```
i do not have permission to use it, but its demonstrates how _dl_runtime_resolve extremely well, and
i dont think i could have created a better graph on how it works.

we need to create 2 fake Elf32_Rel and Elf32_Sym structs, the pass it to _dl_runtime_resolve. This
exploit comes packed with an extremely confusing way of calculating the offset in r_info. This is an
extremely important part of this technique, so let me first explain what r_info is within Elf32_Rel.

This member gives both the symbol table index with respect to which the relocation must be made, and the
type of relocation to apply. For example, a call instruction's relocation entry would hold the symbol
table index of the function being called. Here we can see the macro that defines r_info.
```c
#define ELF32_R_INFO(s,t) (((s)<<8)+(unsigned char)(t))
```
as we can see, it will shift s by 8 bits, then add that with "t" which has the type unsigned char casted
on it. This may seem very confusing, and it is confusing for me as well but this is just how it works.
As the famous king crimson quote goes, "it just works". I like to keep that in mind when approaching
new concepts, as it reminds me that these systems server a purpose, as sometimes they seem to just be
around to complicate things. 

Though, as long as we follow this macro's formula for calculating r_info, it should work just fine.
```c
0x7 | ((locationOfFakeSymtab - symtab) / 16) << 8
```
as long as we follow this formula when calculating the address in which the resolved function should
be written to. Lets walk through this formula and explain what it does, step by step. We provide the
address of our fake FakeSymtab subtracted by the offset to the real symbol table offset. We divide
this by 16, bit shift left by 8, then bitwise operator "or" by 7. For our attack to work, the lower 8
bits must be 0x7 (R_386_JMP_SLOT). The high 24 bits helps the binary find the location of the fake
symtab. Then, I do an extra 4 bytes for alighment afterwards.

Obviously, a massive mitigation against this technique is Position Independent Executable. This means
that our actualy executable will also be randomized when loaded into memory. This is truly the most
devastating exploit mitigation, as combined with ASLR it is impossible to exploit a simple stack overflow
without an arbitrary read or leak. 

Though as of right now, we do not have to worry about our binary being loaded at a random address, this 
means that our PLT/GOT entries will be at a static address, along with our binary sections. We will not 
have to calculate the base address of our binary in memory, and use that offset to reach each section and symbol.

Now lets take a look at our challenge code:
```c
#define _GNU_SOURCE
#include <stdio.h>
void vuln() {
    char buf[20];
    read(0, buf, 500);
}
int main(int argc,char**argv) {
    write(1,"Enter: ",10);
    vuln();
}
```
We can compile the code with the following flags:
```
-fno-stack-protector -no-pie
```
We have a simple stack overflow with this binary, and since we have a write function, why cant
we abuse this to get a ret2plt? We do not have the the sufficient amount of gadgets to pass to
write in order to call write properly. We will have to use ret2dl_resolve if we want to exploit this
binary properly, and if we want to learn :)

The first thing we should do, is define all our sections starts within our exploit script
lets start off with a quick template.

#!/usr/bin/env python3
from pwn import process, ELF, log, context
from fastpwn import pack
context(arch='amd64',os='linux',log_level='DEBUG')
binary=ELF('./lab')
p=binary.process(env={'LD_PRELOAD':'libc.so.6'})
libc=binary.libc

as we can see from the script, there seems to be a library that does not seem to exist anywhere?
what is fastpwn??
well you are in luck, since this is a sponsored message by me, to you.

Are you tired of pwntools taking a darn long time with everything it does?
are you exausted from all the features pwntools provides you?
do you NEED a quick solution that is optimized for performance?

then YOU need fastpwn, a little collection of scripts that i had not taken to time to finish yet!

fastpwn brings you the fastest packing you've ever seen, in the least amount of code its ever been
seen in!

2 unpacking functions, 2 packing functions, all within 4 lines of pretty python code.
do YOU like lambda statements, do YOU appreciate ternary sequences?
then fastpwn is for you!

fastpwn included in local directory, batteries not included.

Lets get back to exploiting this binary, finding the offset to esp/ret addre should be trivial at this
point. Lets do that, and define all important sections and entries within the binary:

#!/usr/bin/env python3
from pwn import process, ELF, log, context
from fastpwn import pack
context(arch='amd64',os='linux',log_level='DEBUG')
binary=ELF('./lab')
p=binary.process()
offset=112
#### define sections of the binary
# since PIE is not enabled, these will be static offsets to whichever section we want
# we will not pack them, since after they are in bytes we cannot use as decimal offsets :(
bss=0x0804c028
plt=0x08049030
rel_plt=0x08048424
dynsym=0x08048260
dynstr=0x08048320
#### Important entries within PLT/GOT
got_read=0x0804c010
plt_read=0x08049050

log.info(".bss: \t%s"%hex(bss))
log.info(".plt: \t%s"%hex(plt))
log.info(".rel.plt: %s"%hex(rel_plt))
log.info(".dynsym:  %s"%hex(dynsym))
log.info(".dynstr:  %s"%hex(dynstr))
log.info("GOT entry to read: %s"%hex(got_read))
log.info("PLT entry to read: %s"%hex(plt_read))

so what we will first have to do, pivot the stack into an area we control. The resulting ROP chain is
going to be pretty big, so we will first need a stack pivot. After we have pivoted the stack, we will
return program execution to main() again, and exploit the vuln except this time we have space to
fit our chain on. We need to craft and calculate our two fake ELF data structures we had spoken about
earlier. We need to create "link_map", and calculate "reloc_arg", as they are parameters that
are passed into __dl_runtime_resolve. The link_map will consist of two data structures we need to
craft as well.

Elf32_Rel and Elf32_Sym:
```c
typedef struct {
    Elf32_Word    st_name;   /* Symbol name (string tbl index) */
    Elf32_Addr    st_value;  /* Symbol value */
    Elf32_Word    st_size;   /* Symbol size */
    unsigned char st_info;   /* Symbol type and binding */
    unsigned char st_other;  /* Symbol visibility under glibc>=2.2 */
    Elf32_Section st_shndx;  /* Section index */
} Elf32_Sym;

Typedef struct {
    Elf32_Addr r_offset; /* got.plt entry */
    Elf32_Word r_info;   /* index from symbol table */
} Elf32_Rel;
```
this is just a reminder of a few entries we will need to populate. We do not need everything within
Elf32_Sym to be populated by a value, only the important ones like st_name, and st_info. Elf32_Rel on
the other hand will need every singe member within this struct populated. We will need to calculate the
offset to our system entry within got.plt, and our index from the symbol table.

## NOT FINISHED
